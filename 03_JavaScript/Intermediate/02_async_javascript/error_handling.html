<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Async Error Handling - JavaScript Intermediate</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .hero {
            text-align: center;
            padding: 60px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .hero h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .hero p {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.9);
            max-width: 600px;
            margin: 0 auto;
        }

        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        .card h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .card h3 {
            color: #34495e;
            margin: 25px 0 15px 0;
            font-size: 1.3em;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            position: relative;
            border-left: 4px solid #3498db;
        }

        .code-block::before {
            content: 'JavaScript';
            position: absolute;
            top: -10px;
            right: 10px;
            background: #3498db;
            color: white;
            padding: 2px 10px;
            border-radius: 3px;
            font-size: 0.8em;
        }

        .demo-container {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .demo-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-warning {
            background: #f39c12;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-success {
            background: #27ae60;
        }

        .btn-success:hover {
            background: #229954;
        }

        .output {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }

        .error-demo {
            background: #ffebee;
            border: 2px solid #f44336;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .error-demo h4 {
            color: #d32f2f;
            margin-bottom: 10px;
        }

        .success-demo {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .success-demo h4 {
            color: #2e7d32;
            margin-bottom: 10px;
        }

        .warning-demo {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .warning-demo h4 {
            color: #f57c00;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }

        .tab {
            background: none;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 0.9em;
            color: #6c757d;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #3498db;
            border-bottom: 2px solid #3498db;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .error-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .error-type {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .error-type h4 {
            color: #e74c3c;
            margin-bottom: 10px;
        }

        .best-practices {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
        }

        .best-practices h3 {
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .best-practices ul {
            list-style: none;
        }

        .best-practices li {
            padding: 8px 0;
            padding-left: 30px;
            position: relative;
        }

        .best-practices li::before {
            content: '✓';
            position: absolute;
            left: 0;
            color: #2ecc71;
            font-weight: bold;
            font-size: 1.2em;
        }

        .highlight {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .highlight h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .highlight p {
            color: #856404;
            line-height: 1.6;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-item {
            padding: 20px;
            border-radius: 10px;
        }

        .comparison-item.before {
            background: #ffebee;
            border: 2px solid #f44336;
        }

        .comparison-item.after {
            background: #e8f5e8;
            border: 2px solid #4caf50;
        }

        .comparison-item h4 {
            margin-bottom: 15px;
            text-align: center;
        }

        .comparison-item.before h4 {
            color: #d32f2f;
        }

        .comparison-item.after h4 {
            color: #2e7d32;
        }

        .error-flow {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .error-step {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 2px solid #dee2e6;
            flex: 1;
            margin: 0 10px;
        }

        .error-arrow {
            font-size: 2em;
            color: #3498db;
            margin: 0 10px;
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }

            .hero h1 {
                font-size: 2.5em;
            }

            .comparison {
                grid-template-columns: 1fr;
            }

            .error-flow {
                flex-direction: column;
            }

            .error-arrow {
                transform: rotate(90deg);
                margin: 10px 0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="hero">
            <h1>Async Error Handling</h1>
            <p>Master error handling in asynchronous JavaScript: try/catch, Promise rejections, and robust error
                management patterns</p>
        </div>

        <div class="content-grid">
            <div class="card">
                <h2>🎯 Try/Catch with Async/Await</h2>

                <h3>Basic Error Handling</h3>
                <div class="code-block">
                    // Basic try/catch with async/await
                    async function fetchUserData(userId) {
                    try {
                    const response = await fetch(`/api/users/${userId}`);

                    if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const userData = await response.json();
                    return userData;
                    } catch (error) {
                    console.error('Error fetching user data:', error.message);
                    throw error; // Re-throw to allow caller to handle
                    }
                    }

                    // Usage with error handling
                    async function displayUser(userId) {
                    try {
                    const user = await fetchUserData(userId);
                    console.log('User:', user);
                    } catch (error) {
                    console.error('Failed to display user:', error.message);
                    // Handle UI error display
                    showErrorMessage('Failed to load user data');
                    }
                    }
                </div>

                <h3>Multiple Async Operations</h3>
                <div class="code-block">
                    // Handling multiple async operations
                    async function processUserData(userId) {
                    try {
                    // Sequential operations - if one fails, others won't execute
                    const user = await fetchUserData(userId);
                    const preferences = await fetchUserPreferences(userId);
                    const permissions = await fetchUserPermissions(userId);

                    return {
                    user,
                    preferences,
                    permissions
                    };
                    } catch (error) {
                    console.error('Error processing user data:', error.message);

                    // Provide partial data if possible
                    return {
                    user: null,
                    preferences: null,
                    permissions: null,
                    error: error.message
                    };
                    }
                    }

                    // Concurrent operations with error handling
                    async function loadUserDashboard(userId) {
                    try {
                    const [user, preferences, permissions] = await Promise.allSettled([
                    fetchUserData(userId),
                    fetchUserPreferences(userId),
                    fetchUserPermissions(userId)
                    ]);

                    return {
                    user: user.status === 'fulfilled' ? user.value : null,
                    preferences: preferences.status === 'fulfilled' ? preferences.value : null,
                    permissions: permissions.status === 'fulfilled' ? permissions.value : null,
                    errors: [user, preferences, permissions]
                    .filter(result => result.status === 'rejected')
                    .map(result => result.reason.message)
                    };
                    } catch (error) {
                    console.error('Unexpected error:', error);
                    throw error;
                    }
                    }
                </div>

                <div class="demo-container">
                    <div class="demo-title">🧪 Try/Catch Demo</div>
                    <button class="btn" onclick="demoTryCatch()">Demo Basic Try/Catch</button>
                    <button class="btn btn-warning" onclick="demoMultipleOperations()">Demo Multiple Operations</button>
                    <div id="tryCatchOutput" class="output"></div>
                </div>
            </div>

            <div class="card">
                <h2>🔥 Promise Error Handling</h2>

                <h3>Promise.catch() Method</h3>
                <div class="code-block">
                    // Promise chain with error handling
                    function fetchDataWithPromises(url) {
                    return fetch(url)
                    .then(response => {
                    if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                    })
                    .then(data => {
                    console.log('Data received:', data);
                    return data;
                    })
                    .catch(error => {
                    console.error('Promise chain error:', error.message);

                    // Return default data or re-throw
                    if (error.message.includes('network')) {
                    return { error: 'Network error', data: null };
                    }
                    throw error;
                    });
                    }

                    // Multiple catch handlers
                    function processDataWithMultipleCatches(url) {
                    return fetch(url)
                    .then(response => {
                    if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                    })
                    .catch(error => {
                    // Handle fetch errors
                    console.error('Fetch error:', error.message);
                    throw new Error('Failed to fetch data');
                    })
                    .then(data => {
                    // Process data
                    if (!data || !data.id) {
                    throw new Error('Invalid data format');
                    }
                    return processData(data);
                    })
                    .catch(error => {
                    // Handle processing errors
                    console.error('Processing error:', error.message);
                    return { processed: false, error: error.message };
                    });
                    }
                </div>

                <h3>Promise.allSettled() for Graceful Degradation</h3>
                <div class="code-block">
                    // Graceful degradation with Promise.allSettled
                    async function loadApplicationData() {
                    const dataPromises = [
                    fetchUserData(),
                    fetchUserPreferences(),
                    fetchNotifications(),
                    fetchRecentActivity()
                    ];

                    const results = await Promise.allSettled(dataPromises);

                    const processedResults = results.map((result, index) => {
                    const dataTypes = ['user', 'preferences', 'notifications', 'activity'];

                    if (result.status === 'fulfilled') {
                    return {
                    type: dataTypes[index],
                    data: result.value,
                    loaded: true
                    };
                    } else {
                    console.error(`Failed to load ${dataTypes[index]}:`, result.reason.message);
                    return {
                    type: dataTypes[index],
                    data: null,
                    loaded: false,
                    error: result.reason.message
                    };
                    }
                    });

                    return processedResults;
                    }

                    // Error recovery strategies
                    async function fetchWithRetry(url, maxRetries = 3) {
                    for (let attempt = 1; attempt <= maxRetries; attempt++) { try { const response=await fetch(url); if
                        (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } return await
                        response.json(); } catch (error) { console.error(`Attempt ${attempt} failed:`, error.message);
                        if (attempt===maxRetries) { throw new Error(`Failed after ${maxRetries} attempts:
                        ${error.message}`); } // Exponential backoff const delay=Math.pow(2, attempt) * 1000; await new
                        Promise(resolve=> setTimeout(resolve, delay));
                        }
                        }
                        }
                </div>

                <div class="demo-container">
                    <div class="demo-title">🔄 Promise Error Demo</div>
                    <button class="btn" onclick="demoPromiseError()">Demo Promise Errors</button>
                    <button class="btn btn-success" onclick="demoAllSettled()">Demo AllSettled</button>
                    <div id="promiseOutput" class="output"></div>
                </div>
            </div>
        </div>

        <div class="content-grid">
            <div class="card">
                <h2>🌐 Global Error Handling</h2>

                <h3>Unhandled Promise Rejections</h3>
                <div class="code-block">
                    // Global unhandled promise rejection handler
                    window.addEventListener('unhandledrejection', (event) => {
                    console.error('Unhandled promise rejection:', event.reason);

                    // Log to error tracking service
                    logErrorToService({
                    type: 'unhandledrejection',
                    message: event.reason?.message || 'Unknown error',
                    stack: event.reason?.stack,
                    timestamp: new Date().toISOString()
                    });

                    // Prevent default browser behavior
                    event.preventDefault();
                    });

                    // Global error handler for runtime errors
                    window.addEventListener('error', (event) => {
                    console.error('Runtime error:', event.error);

                    logErrorToService({
                    type: 'runtime',
                    message: event.message,
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    stack: event.error?.stack,
                    timestamp: new Date().toISOString()
                    });
                    });

                    // Error tracking service
                    class ErrorTracker {
                    constructor() {
                    this.errors = [];
                    this.maxErrors = 100;
                    }

                    logError(error) {
                    const errorEntry = {
                    id: Date.now(),
                    message: error.message,
                    stack: error.stack,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: window.location.href
                    };

                    this.errors.push(errorEntry);

                    // Keep only recent errors
                    if (this.errors.length > this.maxErrors) {
                    this.errors.shift();
                    }

                    // Send to monitoring service
                    this.sendErrorToService(errorEntry);
                    }

                    sendErrorToService(error) {
                    // Simulate sending to error tracking service
                    console.log('Sending error to service:', error);

                    // In real app, send to service like Sentry, LogRocket, etc.
                    // fetch('/api/errors', {
                    // method: 'POST',
                    // headers: { 'Content-Type': 'application/json' },
                    // body: JSON.stringify(error)
                    // }).catch(err => console.error('Failed to send error:', err));
                    }

                    getErrorStats() {
                    return {
                    total: this.errors.length,
                    recent: this.errors.slice(-10),
                    byType: this.errors.reduce((acc, error) => {
                    const type = error.message.split(':')[0];
                    acc[type] = (acc[type] || 0) + 1;
                    return acc;
                    }, {})
                    };
                    }
                    }

                    const errorTracker = new ErrorTracker();
                </div>

                <h3>Error Boundaries for Async Operations</h3>
                <div class="code-block">
                    // Error boundary class for async operations
                    class AsyncErrorBoundary {
                    constructor() {
                    this.errorHandlers = new Map();
                    this.setupGlobalHandlers();
                    }

                    setupGlobalHandlers() {
                    window.addEventListener('unhandledrejection', (event) => {
                    this.handleAsyncError(event.reason);
                    });
                    }

                    register(component, handler) {
                    this.errorHandlers.set(component, handler);
                    }

                    handleAsyncError(error) {
                    console.error('Async error caught by boundary:', error);

                    // Try to find appropriate handler
                    for (const [component, handler] of this.errorHandlers) {
                    if (this.shouldHandle(component, error)) {
                    handler(error);
                    return;
                    }
                    }

                    // Default error handling
                    this.showErrorToUser(error);
                    }

                    shouldHandle(component, error) {
                    // Logic to determine if component should handle this error
                    return error.stack?.includes(component.name);
                    }

                    showErrorToUser(error) {
                    // Display user-friendly error message
                    const errorMessage = this.getUserFriendlyMessage(error);
                    console.log('Showing error to user:', errorMessage);

                    // In real app, show in UI
                    // showNotification(errorMessage, 'error');
                    }

                    getUserFriendlyMessage(error) {
                    if (error.message.includes('network')) {
                    return 'Network connection problem. Please check your internet connection.';
                    }
                    if (error.message.includes('404')) {
                    return 'The requested resource was not found.';
                    }
                    if (error.message.includes('500')) {
                    return 'Server error. Please try again later.';
                    }
                    return 'An unexpected error occurred. Please try again.';
                    }
                    }

                    const asyncErrorBoundary = new AsyncErrorBoundary();
                </div>

                <div class="demo-container">
                    <div class="demo-title">🔍 Global Error Demo</div>
                    <button class="btn btn-danger" onclick="triggerUnhandledRejection()">Trigger Unhandled
                        Rejection</button>
                    <button class="btn btn-warning" onclick="triggerRuntimeError()">Trigger Runtime Error</button>
                    <div id="globalErrorOutput" class="output"></div>
                </div>
            </div>

            <div class="card">
                <h2>⚡ Advanced Error Patterns</h2>

                <div class="tabs">
                    <button class="tab active" onclick="showTab('custom-errors')">Custom Errors</button>
                    <button class="tab" onclick="showTab('error-recovery')">Error Recovery</button>
                    <button class="tab" onclick="showTab('circuit-breaker')">Circuit Breaker</button>
                </div>

                <div id="custom-errors" class="tab-content active">
                    <h3>Custom Error Types</h3>
                    <div class="code-block">
                        // Custom error classes
                        class NetworkError extends Error {
                        constructor(message, statusCode) {
                        super(message);
                        this.name = 'NetworkError';
                        this.statusCode = statusCode;
                        this.timestamp = new Date().toISOString();
                        }
                        }

                        class ValidationError extends Error {
                        constructor(message, field) {
                        super(message);
                        this.name = 'ValidationError';
                        this.field = field;
                        }
                        }

                        class AuthenticationError extends Error {
                        constructor(message) {
                        super(message);
                        this.name = 'AuthenticationError';
                        }
                        }

                        // Usage with custom errors
                        async function apiCall(url, data) {
                        try {
                        const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                        });

                        if (response.status === 401) {
                        throw new AuthenticationError('Invalid credentials');
                        }

                        if (response.status === 400) {
                        const errorData = await response.json();
                        throw new ValidationError(errorData.message, errorData.field);
                        }

                        if (!response.ok) {
                        throw new NetworkError(`HTTP error! status: ${response.status}`, response.status);
                        }

                        return await response.json();
                        } catch (error) {
                        if (error instanceof NetworkError) {
                        console.error('Network issue:', error.message, 'Status:', error.statusCode);
                        } else if (error instanceof ValidationError) {
                        console.error('Validation error:', error.message, 'Field:', error.field);
                        } else if (error instanceof AuthenticationError) {
                        console.error('Auth error:', error.message);
                        // Redirect to login
                        }
                        throw error;
                        }
                        }
                    </div>
                </div>

                <div id="error-recovery" class="tab-content">
                    <h3>Error Recovery Strategies</h3>
                    <div class="code-block">
                        // Auto-retry with exponential backoff
                        class RetryableOperation {
                        constructor(operation, maxRetries = 3) {
                        this.operation = operation;
                        this.maxRetries = maxRetries;
                        }

                        async execute(...args) {
                        for (let attempt = 1; attempt <= this.maxRetries; attempt++) { try { return await
                            this.operation(...args); } catch (error) { console.error(`Attempt ${attempt} failed:`,
                            error.message); if (attempt===this.maxRetries) { throw new Error(`Failed after
                            ${this.maxRetries} attempts: ${error.message}`); } // Exponential backoff with jitter const
                            delay=Math.pow(2, attempt) * 1000 + Math.random() * 1000; await new Promise(resolve=>
                            setTimeout(resolve, delay));
                            }
                            }
                            }
                            }

                            // Fallback data provider
                            class FallbackDataProvider {
                            constructor() {
                            this.cache = new Map();
                            this.fallbackData = new Map();
                            }

                            async getData(key, primaryFetcher, fallbackFetcher) {
                            try {
                            const data = await primaryFetcher(key);
                            this.cache.set(key, data);
                            return data;
                            } catch (error) {
                            console.error('Primary fetch failed:', error.message);

                            // Try cache first
                            if (this.cache.has(key)) {
                            console.log('Returning cached data');
                            return this.cache.get(key);
                            }

                            // Try fallback
                            if (fallbackFetcher) {
                            try {
                            const fallbackData = await fallbackFetcher(key);
                            console.log('Returning fallback data');
                            return fallbackData;
                            } catch (fallbackError) {
                            console.error('Fallback also failed:', fallbackError.message);
                            }
                            }

                            // Return default data if available
                            if (this.fallbackData.has(key)) {
                            console.log('Returning default data');
                            return this.fallbackData.get(key);
                            }

                            throw error;
                            }
                            }

                            setFallbackData(key, data) {
                            this.fallbackData.set(key, data);
                            }
                            }

                            // Usage
                            const retryableApi = new RetryableOperation(fetchUserData);
                            const fallbackProvider = new FallbackDataProvider();
                            fallbackProvider.setFallbackData('user', { name: 'Guest User', id: 'guest' });
                    </div>
                </div>

                <div id="circuit-breaker" class="tab-content">
                    <h3>Circuit Breaker Pattern</h3>
                    <div class="code-block">
                        // Circuit breaker implementation
                        class CircuitBreaker {
                        constructor(operation, options = {}) {
                        this.operation = operation;
                        this.failureThreshold = options.failureThreshold || 5;
                        this.timeout = options.timeout || 10000;
                        this.resetTimeout = options.resetTimeout || 60000;

                        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
                        this.failureCount = 0;
                        this.lastFailureTime = null;
                        this.nextAttempt = null;
                        }

                        async execute(...args) {
                        if (this.state === 'OPEN') {
                        if (Date.now() < this.nextAttempt) { throw new Error('Circuit breaker is OPEN'); }
                            this.state='HALF_OPEN' ; } try { const result=await this.operation(...args); // Success -
                            reset failure count this.failureCount=0; this.state='CLOSED' ; return result; } catch
                            (error) { this.failureCount++; this.lastFailureTime=Date.now(); if (this.failureCount>=
                            this.failureThreshold) {
                            this.state = 'OPEN';
                            this.nextAttempt = Date.now() + this.resetTimeout;
                            console.warn('Circuit breaker opened due to failures');
                            }

                            throw error;
                            }
                            }

                            getState() {
                            return {
                            state: this.state,
                            failureCount: this.failureCount,
                            lastFailureTime: this.lastFailureTime,
                            nextAttempt: this.nextAttempt
                            };
                            }
                            }

                            // Usage
                            const protectedApiCall = new CircuitBreaker(
                            async (url) => {
                            const response = await fetch(url);
                            if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            return response.json();
                            },
                            {
                            failureThreshold: 3,
                            resetTimeout: 30000
                            }
                            );

                            // Monitor circuit breaker state
                            setInterval(() => {
                            const state = protectedApiCall.getState();
                            console.log('Circuit breaker state:', state);
                            }, 5000);
                    </div>
                </div>

                <div class="demo-container">
                    <div class="demo-title">🔧 Advanced Patterns Demo</div>
                    <button class="btn" onclick="demoCustomErrors()">Demo Custom Errors</button>
                    <button class="btn btn-success" onclick="demoErrorRecovery()">Demo Error Recovery</button>
                    <button class="btn btn-warning" onclick="demoCircuitBreaker()">Demo Circuit Breaker</button>
                    <div id="advancedOutput" class="output"></div>
                </div>
            </div>
        </div>

        <div class="error-types">
            <div class="error-type">
                <h4>Network Errors</h4>
                <p>Connection failures, timeouts, DNS issues</p>
            </div>
            <div class="error-type">
                <h4>HTTP Errors</h4>
                <p>4xx client errors, 5xx server errors</p>
            </div>
            <div class="error-type">
                <h4>Parsing Errors</h4>
                <p>JSON parsing failures, invalid data formats</p>
            </div>
            <div class="error-type">
                <h4>Validation Errors</h4>
                <p>Invalid input data, missing required fields</p>
            </div>
        </div>

        <div class="error-flow">
            <div class="error-step">
                <h4>1. Error Occurs</h4>
                <p>Network failure, HTTP error, or validation issue</p>
            </div>
            <div class="error-arrow">→</div>
            <div class="error-step">
                <h4>2. Catch & Classify</h4>
                <p>Identify error type and determine handling strategy</p>
            </div>
            <div class="error-arrow">→</div>
            <div class="error-step">
                <h4>3. Recovery Action</h4>
                <p>Retry, fallback, or graceful degradation</p>
            </div>
            <div class="error-arrow">→</div>
            <div class="error-step">
                <h4>4. User Feedback</h4>
                <p>Show appropriate message and next steps</p>
            </div>
        </div>

        <div class="best-practices">
            <h3>🚀 Error Handling Best Practices</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                <div>
                    <h4>Error Detection</h4>
                    <ul>
                        <li>Always check response status codes</li>
                        <li>Validate data before processing</li>
                        <li>Use type checking for critical operations</li>
                        <li>Monitor for network connectivity</li>
                    </ul>
                </div>
                <div>
                    <h4>Error Recovery</h4>
                    <ul>
                        <li>Implement retry logic with exponential backoff</li>
                        <li>Provide fallback data when possible</li>
                        <li>Use circuit breakers for unstable services</li>
                        <li>Cache successful responses</li>
                    </ul>
                </div>
                <div>
                    <h4>User Experience</h4>
                    <ul>
                        <li>Show user-friendly error messages</li>
                        <li>Provide clear next steps</li>
                        <li>Maintain partial functionality when possible</li>
                        <li>Use loading states and progress indicators</li>
                    </ul>
                </div>
                <div>
                    <h4>Debugging & Monitoring</h4>
                    <ul>
                        <li>Log errors with context and stack traces</li>
                        <li>Use error tracking services</li>
                        <li>Monitor error rates and patterns</li>
                        <li>Set up alerts for critical errors</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="highlight">
            <h3>🔮 Advanced Error Handling Techniques</h3>
            <p>
                <strong>Error Boundaries:</strong> Isolate errors to prevent cascading failures across your
                application.<br>
                <strong>Progressive Enhancement:</strong> Build features that gracefully degrade when dependencies
                fail.<br>
                <strong>Observability:</strong> Implement comprehensive logging and monitoring for proactive error
                detection.<br>
                <strong>Error Recovery:</strong> Design systems that can automatically recover from transient
                failures.<br>
                <strong>User Communication:</strong> Provide clear, actionable error messages that guide users toward
                resolution.
            </p>
        </div>
    </div>

    <script>
        // Demo Functions
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // Try/Catch Demos
        async function demoTryCatch() {
            const output = document.getElementById('tryCatchOutput');
            let result = 'Try/Catch Demo Results:\n\n';

            try {
                result += '1. Successful async operation:\n';
                const data = await simulateAsyncOperation(true);
                result += `   ✓ Success: ${JSON.stringify(data)}\n\n`;
            } catch (error) {
                result += `   ✗ Error: ${error.message}\n\n`;
            }

            try {
                result += '2. Failed async operation:\n';
                const data = await simulateAsyncOperation(false);
                result += `   ✓ Success: ${JSON.stringify(data)}\n\n`;
            } catch (error) {
                result += `   ✗ Error caught: ${error.message}\n\n`;
            }

            output.textContent = result;
        }

        async function demoMultipleOperations() {
            const output = document.getElementById('tryCatchOutput');
            let result = 'Multiple Operations Demo:\n\n';

            try {
                result += 'Using Promise.allSettled for graceful degradation:\n';
                const promises = [
                    simulateAsyncOperation(true),
                    simulateAsyncOperation(false),
                    simulateAsyncOperation(true)
                ];

                const results = await Promise.allSettled(promises);

                results.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        result += `   Operation ${index + 1}: ✓ Success\n`;
                    } else {
                        result += `   Operation ${index + 1}: ✗ Failed - ${result.reason.message}\n`;
                    }
                });

                const successCount = results.filter(r => r.status === 'fulfilled').length;
                result += `\nSummary: ${successCount}/${results.length} operations succeeded\n`;
            } catch (error) {
                result += `Unexpected error: ${error.message}\n`;
            }

            output.textContent = result;
        }

        // Promise Error Demos
        async function demoPromiseError() {
            const output = document.getElementById('promiseOutput');
            let result = 'Promise Error Handling Demo:\n\n';

            // Promise chain with catch
            result += '1. Promise chain with .catch():\n';
            await simulatePromiseChain()
                .then(data => {
                    result += `   ✓ Success: ${JSON.stringify(data)}\n`;
                })
                .catch(error => {
                    result += `   ✗ Caught in chain: ${error.message}\n`;
                });

            result += '\n2. Promise with retry logic:\n';
            try {
                const data = await simulateRetryOperation();
                result += `   ✓ Success after retries: ${JSON.stringify(data)}\n`;
            } catch (error) {
                result += `   ✗ Failed after retries: ${error.message}\n`;
            }

            output.textContent = result;
        }

        async function demoAllSettled() {
            const output = document.getElementById('promiseOutput');
            let result = 'Promise.allSettled Demo:\n\n';

            const operations = [
                () => simulateAsyncOperation(true),
                () => simulateAsyncOperation(false),
                () => simulateAsyncOperation(true),
                () => simulateAsyncOperation(false)
            ];

            const results = await Promise.allSettled(
                operations.map(op => op())
            );

            results.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    result += `Operation ${index + 1}: ✓ Fulfilled\n`;
                } else {
                    result += `Operation ${index + 1}: ✗ Rejected - ${result.reason.message}\n`;
                }
            });

            const stats = results.reduce((acc, result) => {
                acc[result.status]++;
                return acc;
            }, { fulfilled: 0, rejected: 0 });

            result += `\nStats: ${stats.fulfilled} fulfilled, ${stats.rejected} rejected\n`;
            output.textContent = result;
        }

        // Global Error Demos
        function triggerUnhandledRejection() {
            const output = document.getElementById('globalErrorOutput');
            output.textContent = 'Triggering unhandled promise rejection...\n';

            // This will trigger the global unhandledrejection handler
            Promise.reject(new Error('This is an unhandled promise rejection'));

            setTimeout(() => {
                output.textContent += 'Check browser console for global error handler output.\n';
            }, 100);
        }

        function triggerRuntimeError() {
            const output = document.getElementById('globalErrorOutput');
            output.textContent = 'Triggering runtime error...\n';

            setTimeout(() => {
                // This will trigger the global error handler
                throw new Error('This is a runtime error');
            }, 100);
        }

        // Advanced Pattern Demos
        async function demoCustomErrors() {
            const output = document.getElementById('advancedOutput');
            let result = 'Custom Error Types Demo:\n\n';

            try {
                await simulateCustomError('network');
            } catch (error) {
                result += `Caught ${error.name}: ${error.message}\n`;
                if (error.statusCode) {
                    result += `   Status Code: ${error.statusCode}\n`;
                }
            }

            try {
                await simulateCustomError('validation');
            } catch (error) {
                result += `Caught ${error.name}: ${error.message}\n`;
                if (error.field) {
                    result += `   Field: ${error.field}\n`;
                }
            }

            output.textContent = result;
        }

        async function demoErrorRecovery() {
            const output = document.getElementById('advancedOutput');
            let result = 'Error Recovery Demo:\n\n';

            const retryOperation = new RetryableOperation(
                () => simulateAsyncOperation(Math.random() > 0.3),
                2
            );

            try {
                result += 'Attempting operation with retry logic...\n';
                const data = await retryOperation.execute();
                result += `✓ Success: ${JSON.stringify(data)}\n`;
            } catch (error) {
                result += `✗ Failed after retries: ${error.message}\n`;
            }

            output.textContent = result;
        }

        async function demoCircuitBreaker() {
            const output = document.getElementById('advancedOutput');
            let result = 'Circuit Breaker Demo:\n\n';

            const circuitBreaker = new CircuitBreaker(
                () => simulateAsyncOperation(Math.random() > 0.7),
                { failureThreshold: 2, resetTimeout: 5000 }
            );

            for (let i = 1; i <= 5; i++) {
                try {
                    result += `Attempt ${i}: `;
                    await circuitBreaker.execute();
                    result += 'Success\n';
                } catch (error) {
                    result += `Failed - ${error.message}\n`;
                }

                const state = circuitBreaker.getState();
                result += `   Circuit state: ${state.state} (failures: ${state.failureCount})\n`;
            }

            output.textContent = result;
        }

        // Utility Functions
        function simulateAsyncOperation(shouldSucceed) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (shouldSucceed) {
                        resolve({ data: 'Operation successful', timestamp: Date.now() });
                    } else {
                        reject(new Error('Operation failed'));
                    }
                }, 500);
            });
        }

        function simulatePromiseChain() {
            return Promise.resolve('Initial data')
                .then(data => {
                    if (Math.random() > 0.5) {
                        throw new Error('Random failure in chain');
                    }
                    return { processed: data, step: 1 };
                })
                .then(data => {
                    return { ...data, step: 2 };
                });
        }

        async function simulateRetryOperation() {
            const maxRetries = 3;
            let attempts = 0;

            while (attempts < maxRetries) {
                attempts++;
                try {
                    if (Math.random() > 0.5) {
                        return { data: 'Success', attempts };
                    }
                    throw new Error(`Attempt ${attempts} failed`);
                } catch (error) {
                    if (attempts === maxRetries) {
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
        }

        function simulateCustomError(type) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    switch (type) {
                        case 'network':
                            reject(new NetworkError('Connection failed', 500));
                            break;
                        case 'validation':
                            reject(new ValidationError('Email is required', 'email'));
                            break;
                        case 'auth':
                            reject(new AuthenticationError('Invalid token'));
                            break;
                        default:
                            reject(new Error('Unknown error'));
                    }
                }, 300);
            });
        }

        // Custom Error Classes (for demo)
        class NetworkError extends Error {
            constructor(message, statusCode) {
                super(message);
                this.name = 'NetworkError';
                this.statusCode = statusCode;
            }
        }

        class ValidationError extends Error {
            constructor(message, field) {
                super(message);
                this.name = 'ValidationError';
                this.field = field;
            }
        }

        class AuthenticationError extends Error {
            constructor(message) {
                super(message);
                this.name = 'AuthenticationError';
            }
        }

        // RetryableOperation class (for demo)
        class RetryableOperation {
            constructor(operation, maxRetries = 3) {
                this.operation = operation;
                this.maxRetries = maxRetries;
            }

            async execute(...args) {
                for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
                    try {
                        return await this.operation(...args);
                    } catch (error) {
                        if (attempt === this.maxRetries) {
                            throw error;
                        }
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            }
        }

        // Circuit Breaker class (for demo)
        class CircuitBreaker {
            constructor(operation, options = {}) {
                this.operation = operation;
                this.failureThreshold = options.failureThreshold || 5;
                this.resetTimeout = options.resetTimeout || 60000;
                this.state = 'CLOSED';
                this.failureCount = 0;
                this.nextAttempt = null;
            }

            async execute(...args) {
                if (this.state === 'OPEN') {
                    if (Date.now() < this.nextAttempt) {
                        throw new Error('Circuit breaker is OPEN');
                    }
                    this.state = 'HALF_OPEN';
                }

                try {
                    const result = await this.operation(...args);
                    this.failureCount = 0;
                    this.state = 'CLOSED';
                    return result;
                } catch (error) {
                    this.failureCount++;
                    if (this.failureCount >= this.failureThreshold) {
                        this.state = 'OPEN';
                        this.nextAttempt = Date.now() + this.resetTimeout;
                    }
                    throw error;
                }
            }

            getState() {
                return {
                    state: this.state,
                    failureCount: this.failureCount,
                    nextAttempt: this.nextAttempt
                };
            }
        }

        // Global error handlers
        window.addEventListener('unhandledrejection', (event) => {
            console.error('🔥 Unhandled promise rejection:', event.reason);
            event.preventDefault();
        });

        window.addEventListener('error', (event) => {
            console.error('💥 Runtime error:', event.error);
        });

        // Initialize page
        document.addEventListener('DOMContentLoaded', function () {
            console.log('🚀 Async Error Handling guide loaded');
        });
    </script>
</body>

</html>