<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES6 Arrow Functions - Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .hero {
            text-align: center;
            padding: 60px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            margin-bottom: 40px;
            backdrop-filter: blur(10px);
        }

        .hero h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .hero p {
            font-size: 1.3em;
            color: rgba(255, 255, 255, 0.9);
            max-width: 600px;
            margin: 0 auto;
        }

        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-bottom: 40px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .card h3 {
            color: #764ba2;
            margin: 25px 0 15px 0;
            font-size: 1.3em;
        }

        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            position: relative;
        }

        .code-block::before {
            content: attr(data-language);
            position: absolute;
            top: -12px;
            right: 15px;
            background: #667eea;
            color: white;
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 0.8em;
        }

        .demo-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .demo-title {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
        }

        .output {
            background: #2d3748;
            color: #68d391;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
        }

        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }

        .best-practices {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
        }

        .best-practices h3 {
            color: white;
            margin-bottom: 15px;
        }

        .best-practices ul {
            list-style: none;
            padding-left: 0;
        }

        .best-practices li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
        }

        .best-practices li::before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #68d391;
            font-weight: bold;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-item {
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .comparison-item.before {
            background: #fff5f5;
            border-color: #feb2b2;
        }

        .comparison-item.after {
            background: #f0fff4;
            border-color: #9ae6b4;
        }

        .comparison-item h4 {
            margin-bottom: 10px;
            color: #2d3748;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            padding: 10px 20px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 1em;
            border-radius: 8px 8px 0 0;
            margin-right: 5px;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: #667eea;
            color: white;
        }

        .tab-content {
            display: none;
            padding: 20px;
            background: white;
            border-radius: 0 8px 8px 8px;
        }

        .tab-content.active {
            display: block;
        }

        .performance-chart {
            display: flex;
            align-items: end;
            height: 200px;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .performance-bar {
            flex: 1;
            margin: 0 10px;
            text-align: center;
        }

        .bar {
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 4px 4px 0 0;
            transition: all 0.3s ease;
        }

        .bar-label {
            margin-top: 10px;
            font-weight: bold;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }

            .hero h1 {
                font-size: 2.5em;
            }

            .comparison {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="hero">
            <h1>ES6 Arrow Functions</h1>
            <p>Master the power of arrow functions: syntax, behavior, and advanced patterns for modern JavaScript
                development</p>
        </div>

        <div class="content-grid">
            <div class="card">
                <h2>üéØ Arrow Function Basics</h2>

                <h3>Syntax Comparison</h3>
                <div class="comparison">
                    <div class="comparison-item before">
                        <h4>Traditional Function</h4>
                        <div class="code-block" data-language="JavaScript">
                            function add(a, b) {
                            return a + b;
                            }

                            const multiply = function(a, b) {
                            return a * b;
                            };

                            const greet = function(name) {
                            return "Hello, " + name;
                            };
                        </div>
                    </div>
                    <div class="comparison-item after">
                        <h4>Arrow Function</h4>
                        <div class="code-block" data-language="JavaScript">
                            const add = (a, b) => a + b;

                            const multiply = (a, b) => a * b;

                            const greet = name => `Hello, ${name}`;
                        </div>
                    </div>
                </div>

                <h3>Syntax Variations</h3>
                <div class="code-block" data-language="JavaScript">
                    // No parameters
                    const getName = () => "John Doe";

                    // Single parameter (parentheses optional)
                    const square = x => x * x;
                    const square2 = (x) => x * x;

                    // Multiple parameters
                    const add = (a, b) => a + b;
                    const fullName = (first, last) => `${first} ${last}`;

                    // Single expression (implicit return)
                    const double = x => x * 2;

                    // Multiple statements (explicit return)
                    const processData = (data) => {
                    const processed = data.map(item => item.toUpperCase());
                    const filtered = processed.filter(item => item.length > 3);
                    return filtered;
                    };

                    // Returning object literal (wrap in parentheses)
                    const createUser = (name, age) => ({
                    name,
                    age,
                    id: Math.random(),
                    createdAt: new Date()
                    });

                    // Destructuring parameters
                    const getUserInfo = ({name, age, email}) => {
                    return `${name} (${age}) - ${email}`;
                    };

                    // Rest parameters
                    const sum = (...numbers) => {
                    return numbers.reduce((total, num) => total + num, 0);
                    };

                    // Default parameters
                    const greetUser = (name = "Guest", greeting = "Hello") => {
                    return `${greeting}, ${name}!`;
                    };
                </div>

                <div class="demo-container">
                    <div class="demo-title">üéØ Basic Arrow Function Demo</div>
                    <button onclick="runBasicDemo()">Run Basic Examples</button>
                    <div id="basic-output" class="output" style="display: none;"></div>
                </div>
            </div>

            <div class="card">
                <h2>üîß The 'this' Binding</h2>

                <h3>Traditional Function vs Arrow Function</h3>
                <div class="code-block" data-language="JavaScript">
                    // Traditional function - 'this' is dynamic
                    const obj1 = {
                    name: "Traditional",
                    methods: {
                    regularFunction: function() {
                    console.log("Regular function this:", this);
                    return this.name;
                    },

                    arrowFunction: () => {
                    console.log("Arrow function this:", this);
                    return this.name; // 'this' refers to global/window
                    }
                    }
                    };

                    // Arrow function - 'this' is lexical
                    const obj2 = {
                    name: "Arrow",

                    init: function() {
                    // 'this' refers to obj2
                    this.regularMethod = function() {
                    return this.name; // 'this' refers to caller
                    };

                    this.arrowMethod = () => {
                    return this.name; // 'this' refers to obj2
                    };
                    }
                    };

                    obj2.init();

                    // Event handling differences
                    class Button {
                    constructor(element) {
                    this.element = element;
                    this.clickCount = 0;

                    // Traditional function - 'this' changes
                    this.element.addEventListener('click', function() {
                    console.log(this); // 'this' is the button element
                    this.clickCount++; // Error: this.clickCount is undefined
                    });

                    // Arrow function - 'this' preserved
                    this.element.addEventListener('click', () => {
                    console.log(this); // 'this' is the Button instance
                    this.clickCount++; // Works correctly
                    });
                    }
                    }

                    // Method definitions
                    class User {
                    constructor(name) {
                    this.name = name;
                    }

                    // Traditional method
                    sayHello() {
                    return `Hello, I'm ${this.name}`;
                    }

                    // Arrow function property
                    sayGoodbye = () => {
                    return `Goodbye from ${this.name}`;
                    }

                    // Method that returns arrow function
                    getGreeter() {
                    return () => {
                    return `Greetings from ${this.name}`;
                    };
                    }
                    }

                    const user = new User("Alice");
                    const greeter = user.getGreeter();
                    console.log(greeter()); // "Greetings from Alice"

                    // Arrow functions can't be used as constructors
                    const ArrowConstructor = () => {
                    this.name = "Test";
                    };

                    // This will throw an error
                    // new ArrowConstructor(); // TypeError: ArrowConstructor is not a constructor
                </div>

                <h3>Practical Examples</h3>
                <div class="code-block" data-language="JavaScript">
                    // React component example
                    class TodoList extends React.Component {
                    constructor(props) {
                    super(props);
                    this.state = {
                    todos: [],
                    inputValue: ''
                    };
                    }

                    // Arrow function preserves 'this'
                    handleInputChange = (event) => {
                    this.setState({ inputValue: event.target.value });
                    }

                    handleSubmit = (event) => {
                    event.preventDefault();
                    this.setState(prevState => ({
                    todos: [...prevState.todos, prevState.inputValue],
                    inputValue: ''
                    }));
                    }

                    render() {
                    return (
                    <form onSubmit={this.handleSubmit}>
                        <input value={this.state.inputValue} onChange={this.handleInputChange} />
                        <button type="submit">Add Todo</button>
                    </form>
                    );
                    }
                    }

                    // Timer example
                    class Timer {
                    constructor() {
                    this.seconds = 0;
                    this.intervalId = null;
                    }

                    start() {
                    // Arrow function preserves 'this'
                    this.intervalId = setInterval(() => {
                    this.seconds++;
                    console.log(`Timer: ${this.seconds} seconds`);
                    }, 1000);
                    }

                    stop() {
                    clearInterval(this.intervalId);
                    }

                    reset() {
                    this.seconds = 0;
                    }
                    }

                    // API call with proper 'this' binding
                    class ApiClient {
                    constructor(baseUrl) {
                    this.baseUrl = baseUrl;
                    this.token = null;
                    }

                    setToken(token) {
                    this.token = token;
                    }

                    // Arrow function preserves 'this'
                    request = async (endpoint, options = {}) => {
                    const url = `${this.baseUrl}${endpoint}`;
                    const headers = {
                    'Content-Type': 'application/json',
                    ...(this.token && { Authorization: `Bearer ${this.token}` }),
                    ...options.headers
                    };

                    const response = await fetch(url, {
                    ...options,
                    headers
                    });

                    if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    return response.json();
                    }
                    }
                </div>

                <div class="demo-container">
                    <div class="demo-title">üîß 'this' Binding Demo</div>
                    <button onclick="runThisDemo()">Run This Binding Examples</button>
                    <div id="this-output" class="output" style="display: none;"></div>
                </div>
            </div>

            <div class="card">
                <h2>üöÄ Advanced Arrow Function Patterns</h2>

                <h3>Higher-Order Functions</h3>
                <div class="code-block" data-language="JavaScript">
                    // Function that returns a function
                    const createMultiplier = (multiplier) => (value) => value * multiplier;

                    const double = createMultiplier(2);
                    const triple = createMultiplier(3);

                    console.log(double(5)); // 10
                    console.log(triple(4)); // 12

                    // Currying with arrow functions
                    const curry = (fn) => (...args) => {
                    if (args.length >= fn.length) {
                    return fn(...args);
                    }
                    return (...nextArgs) => curry(fn)(...args, ...nextArgs);
                    };

                    const add = (a, b, c) => a + b + c;
                    const curriedAdd = curry(add);

                    console.log(curriedAdd(1)(2)(3)); // 6
                    console.log(curriedAdd(1, 2)(3)); // 6

                    // Composition
                    const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);

                    const addOne = x => x + 1;
                    const square = x => x * x;
                    const halve = x => x / 2;

                    const transform = compose(halve, square, addOne);
                    console.log(transform(3)); // ((3 + 1) ^ 2) / 2 = 8

                    // Partial application
                    const partial = (fn, ...args1) => (...args2) => fn(...args1, ...args2);

                    const log = (level, message, timestamp) => {
                    console.log(`[${timestamp}] ${level}: ${message}`);
                    };

                    const logError = partial(log, 'ERROR');
                    const logInfo = partial(log, 'INFO');

                    logError('Something went wrong', new Date().toISOString());
                    logInfo('Process completed', new Date().toISOString());
                </div>

                <h3>Functional Programming Patterns</h3>
                <div class="code-block" data-language="JavaScript">
                    // Array methods with arrow functions
                    const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

                    // Chaining operations
                    const result = numbers
                    .filter(n => n % 2 === 0) // Even numbers
                    .map(n => n * n) // Square them
                    .reduce((sum, n) => sum + n, 0); // Sum them

                    console.log(result); // 220

                    // Complex data transformation
                    const users = [
                    { name: 'Alice', age: 30, skills: ['JavaScript', 'React'] },
                    { name: 'Bob', age: 25, skills: ['Python', 'Django'] },
                    { name: 'Charlie', age: 35, skills: ['JavaScript', 'Node.js'] }
                    ];

                    const jsUsers = users
                    .filter(user => user.skills.includes('JavaScript'))
                    .map(user => ({
                    ...user,
                    isJsDeveloper: true,
                    experience: user.age - 20
                    }))
                    .sort((a, b) => b.experience - a.experience);

                    // Async operations
                    const fetchUserData = async (userId) => {
                    const response = await fetch(`/api/users/${userId}`);
                    return response.json();
                    };

                    const processUsers = async (userIds) => {
                    const userPromises = userIds.map(id => fetchUserData(id));
                    const users = await Promise.all(userPromises);

                    return users
                    .filter(user => user.isActive)
                    .map(user => ({
                    id: user.id,
                    name: user.name,
                    lastActive: new Date(user.lastActive)
                    }));
                    };

                    // Event handling with arrow functions
                    const setupEventListeners = () => {
                    const buttons = document.querySelectorAll('button');

                    buttons.forEach(button => {
                    button.addEventListener('click', (event) => {
                    const action = event.target.dataset.action;
                    console.log(`Button clicked: ${action}`);
                    });
                    });
                    };

                    // Debouncing and throttling
                    const debounce = (func, wait) => {
                    let timeout;
                    return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func(...args), wait);
                    };
                    };

                    const throttle = (func, limit) => {
                    let inThrottle;
                    return (...args) => {
                    if (!inThrottle) {
                    func(...args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                    }
                    };
                    };

                    // Usage
                    const expensiveOperation = (data) => {
                    console.log('Processing:', data);
                    };

                    const debouncedOperation = debounce(expensiveOperation, 300);
                    const throttledOperation = throttle(expensiveOperation, 1000);
                </div>

                <h3>Async Arrow Functions</h3>
                <div class="code-block" data-language="JavaScript">
                    // Async arrow functions
                    const fetchData = async (url) => {
                    try {
                    const response = await fetch(url);
                    const data = await response.json();
                    return data;
                    } catch (error) {
                    console.error('Fetch error:', error);
                    throw error;
                    }
                    };

                    // Parallel async operations
                    const fetchMultipleResources = async (urls) => {
                    const promises = urls.map(url => fetchData(url));
                    return Promise.all(promises);
                    };

                    // Sequential async operations
                    const fetchSequentially = async (urls) => {
                    const results = [];
                    for (const url of urls) {
                    const data = await fetchData(url);
                    results.push(data);
                    }
                    return results;
                    };

                    // Async array methods
                    const asyncMap = async (array, asyncFn) => {
                    const promises = array.map(asyncFn);
                    return Promise.all(promises);
                    };

                    const asyncFilter = async (array, asyncPredicate) => {
                    const results = await asyncMap(array, asyncPredicate);
                    return array.filter((_, index) => results[index]);
                    };

                    // Usage
                    const urls = ['/api/users', '/api/posts', '/api/comments'];
                    const processApiData = async () => {
                    const [users, posts, comments] = await fetchMultipleResources(urls);

                    const activeUsers = await asyncFilter(users, async user => {
                    const profile = await fetchData(`/api/users/${user.id}/profile`);
                    return profile.isActive;
                    });

                    return { users: activeUsers, posts, comments };
                    };

                    // Error handling with async arrow functions
                    const withErrorHandling = (asyncFn) => async (...args) => {
                    try {
                    return await asyncFn(...args);
                    } catch (error) {
                    console.error('Error in async function:', error);
                    throw error;
                    }
                    };

                    const safeApiCall = withErrorHandling(fetchData);
                </div>

                <div class="demo-container">
                    <div class="demo-title">üöÄ Advanced Patterns Demo</div>
                    <button onclick="runAdvancedDemo()">Run Advanced Examples</button>
                    <div id="advanced-output" class="output" style="display: none;"></div>
                </div>
            </div>

            <div class="card">
                <h2>‚ö° Performance Considerations</h2>

                <h3>Performance Comparison</h3>
                <div class="performance-chart">
                    <div class="performance-bar">
                        <div class="bar" style="height: 90px;" data-value="90"></div>
                        <div class="bar-label">Regular Function</div>
                    </div>
                    <div class="performance-bar">
                        <div class="bar" style="height: 95px;" data-value="95"></div>
                        <div class="bar-label">Arrow Function</div>
                    </div>
                    <div class="performance-bar">
                        <div class="bar" style="height: 100px;" data-value="100"></div>
                        <div class="bar-label">Method Call</div>
                    </div>
                </div>

                <h3>Memory Usage</h3>
                <div class="code-block" data-language="JavaScript">
                    // Memory considerations
                    class ComponentWithMethods {
                    constructor() {
                    this.data = [];

                    // Arrow function property - created for each instance
                    this.processData = () => {
                    return this.data.map(item => item.value);
                    };
                    }

                    // Regular method - shared across all instances
                    processDataMethod() {
                    return this.data.map(item => item.value);
                    }
                    }

                    // Memory-efficient approach
                    class EfficientComponent {
                    constructor() {
                    this.data = [];
                    }

                    // Use regular methods for shared functionality
                    processData() {
                    return this.data.map(item => item.value);
                    }

                    // Use arrow functions only when 'this' binding is needed
                    setupEventListeners() {
                    const button = document.querySelector('#my-button');
                    button.addEventListener('click', () => {
                    this.processData(); // Arrow function preserves 'this'
                    });
                    }
                    }

                    // Performance benchmark
                    function benchmarkFunctions() {
                    const iterations = 1000000;

                    // Regular function
                    const regular = function(x) { return x * 2; };

                    // Arrow function
                    const arrow = x => x * 2;

                    // Method
                    const obj = {
                    method: function(x) { return x * 2; }
                    };

                    console.time('Regular Function');
                    for (let i = 0; i < iterations; i++) { regular(i); } console.timeEnd('Regular Function');
                        console.time('Arrow Function'); for (let i=0; i < iterations; i++) { arrow(i); }
                        console.timeEnd('Arrow Function'); console.time('Method Call'); for (let i=0; i < iterations;
                        i++) { obj.method(i); } console.timeEnd('Method Call'); } // Best practices for performance
                        const optimizedPatterns={ // Good: Reuse arrow functions setupHandlers() { const
                        clickHandler=(event)=> {
                        console.log('Clicked:', event.target);
                        };

                        document.querySelectorAll('button').forEach(button => {
                        button.addEventListener('click', clickHandler);
                        });
                        },

                        // Bad: Creating new arrow functions in loops
                        inefficientSetup() {
                        document.querySelectorAll('button').forEach(button => {
                        button.addEventListener('click', (event) => {
                        console.log('Clicked:', event.target);
                        });
                        });
                        }
                        };
                </div>

                <h3>When to Use Arrow Functions</h3>
                <div class="code-block" data-language="JavaScript">
                    // ‚úÖ Good use cases for arrow functions

                    // 1. Array methods and functional programming
                    const numbers = [1, 2, 3, 4, 5];
                    const doubled = numbers.map(n => n * 2);
                    const evens = numbers.filter(n => n % 2 === 0);
                    const sum = numbers.reduce((acc, n) => acc + n, 0);

                    // 2. Event handlers in classes
                    class Button {
                    constructor() {
                    this.clickCount = 0;
                    }

                    init() {
                    document.addEventListener('click', () => {
                    this.clickCount++; // 'this' is preserved
                    });
                    }
                    }

                    // 3. Callbacks that need to preserve 'this'
                    class ApiService {
                    constructor() {
                    this.baseUrl = 'https://api.example.com';
                    }

                    fetchData(endpoint) {
                    return fetch(`${this.baseUrl}${endpoint}`)
                    .then(response => response.json()) // Arrow function preserves 'this'
                    .then(data => this.processData(data));
                    }

                    processData(data) {
                    // Process the data
                    return data;
                    }
                    }

                    // 4. Short, simple functions
                    const isEven = n => n % 2 === 0;
                    const square = x => x * x;
                    const getName = user => user.name;

                    // ‚ùå Avoid arrow functions for:

                    // 1. Object methods (unless you need lexical 'this')
                    const obj = {
                    name: 'MyObject',
                    // Bad: 'this' won't refer to obj
                    arrowMethod: () => {
                    return this.name; // undefined
                    },
                    // Good: 'this' refers to obj
                    regularMethod() {
                    return this.name; // 'MyObject'
                    }
                    };

                    // 2. Prototype methods
                    function Person(name) {
                    this.name = name;
                    }

                    // Bad: Arrow function doesn't have dynamic 'this'
                    Person.prototype.greet = () => {
                    return `Hello, I'm ${this.name}`;
                    };

                    // Good: Regular function has dynamic 'this'
                    Person.prototype.greet = function() {
                    return `Hello, I'm ${this.name}`;
                    };

                    // 3. Constructors
                    // Bad: Arrow functions can't be constructors
                    const Constructor = () => {
                    this.value = 42;
                    };

                    // Good: Regular function constructor
                    function Constructor() {
                    this.value = 42;
                    }

                    // 4. Methods that need to be hoisted
                    // Bad: Arrow functions are not hoisted
                    const calculate = () => {
                    return helper(); // ReferenceError
                    };

                    const helper = () => {
                    return 42;
                    };

                    // Good: Function declarations are hoisted
                    function calculate() {
                    return helper(); // Works fine
                    }

                    function helper() {
                    return 42;
                    }
                </div>

                <div class="demo-container">
                    <div class="demo-title">‚ö° Performance Demo</div>
                    <button onclick="runPerformanceDemo()">Run Performance Tests</button>
                    <div id="performance-output" class="output" style="display: none;"></div>
                </div>
            </div>

            <div class="card">
                <h2>üõ†Ô∏è Real-World Applications</h2>

                <div class="tabs">
                    <button class="tab active" onclick="showTab('react')">React</button>
                    <button class="tab" onclick="showTab('nodejs')">Node.js</button>
                    <button class="tab" onclick="showTab('async')">Async/Await</button>
                    <button class="tab" onclick="showTab('functional')">Functional</button>
                </div>

                <div id="react" class="tab-content active">
                    <h3>React Components</h3>
                    <div class="code-block" data-language="JavaScript">
                        // Functional component with hooks
                        const UserProfile = ({ userId }) => {
                        const [user, setUser] = useState(null);
                        const [loading, setLoading] = useState(true);

                        useEffect(() => {
                        const fetchUser = async () => {
                        try {
                        const response = await fetch(`/api/users/${userId}`);
                        const userData = await response.json();
                        setUser(userData);
                        } catch (error) {
                        console.error('Error fetching user:', error);
                        } finally {
                        setLoading(false);
                        }
                        };

                        fetchUser();
                        }, [userId]);

                        const handleEdit = () => {
                        // Handle edit logic
                        console.log('Editing user:', user.id);
                        };

                        if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
                        if (!user) return &lt;div&gt;User not found&lt;/div&gt;;

                        return (
                        &lt;div className="user-profile"&gt;
                        &lt;h1&gt;{user.name}&lt;/h1&gt;
                        &lt;p&gt;{user.email}&lt;/p&gt;
                        &lt;button onClick={handleEdit}&gt;Edit Profile&lt;/button&gt;
                        &lt;/div&gt;
                        );
                        };

                        // Custom hooks with arrow functions
                        const useLocalStorage = (key, initialValue) => {
                        const [storedValue, setStoredValue] = useState(() => {
                        try {
                        const item = window.localStorage.getItem(key);
                        return item ? JSON.parse(item) : initialValue;
                        } catch (error) {
                        return initialValue;
                        }
                        });

                        const setValue = (value) => {
                        try {
                        const valueToStore = value instanceof Function ? value(storedValue) : value;
                        setStoredValue(valueToStore);
                        window.localStorage.setItem(key, JSON.stringify(valueToStore));
                        } catch (error) {
                        console.error('Error setting localStorage:', error);
                        }
                        };

                        return [storedValue, setValue];
                        };

                        // Higher-order component
                        const withLoading = (Component) => (props) => {
                        const [loading, setLoading] = useState(true);

                        useEffect(() => {
                        const timer = setTimeout(() => setLoading(false), 1000);
                        return () => clearTimeout(timer);
                        }, []);

                        if (loading) {
                        return &lt;div&gt;Loading...&lt;/div&gt;;
                        }

                        return (
                        &lt;Component {...props} /&gt;
                        );
                        };

                        // Event handlers
                        const TodoList = () => {
                        const [todos, setTodos] = useState([]);
                        const [inputValue, setInputValue] = useState('');

                        const addTodo = () => {
                        if (inputValue.trim()) {
                        setTodos(prev => [...prev, {
                        id: Date.now(),
                        text: inputValue,
                        completed: false
                        }]);
                        setInputValue('');
                        }
                        };

                        const toggleTodo = (id) => {
                        setTodos(prev => prev.map(todo =>
                        todo.id === id ? { ...todo, completed: !todo.completed } : todo
                        ));
                        };

                        const deleteTodo = (id) => {
                        setTodos(prev => prev.filter(todo => todo.id !== id));
                        };

                        return (
                        /* JSX Code */
                        &lt;div&gt;
                        &lt;input
                        value={inputValue}
                        onChange={(e) =&gt; setInputValue(e.target.value)}
                        onKeyPress={(e) =&gt; e.key === 'Enter' &amp;&amp; addTodo()}
                        /&gt;
                        &lt;button onClick={addTodo}&gt;Add Todo&lt;/button&gt;

                        &lt;ul&gt;
                        {todos.map(todo =&gt; (
                        &lt;li key={todo.id}&gt;
                        &lt;span
                        style={todo.completed ? {textDecoration: 'line-through'} : {}}
                        onClick={() =&gt; toggleTodo(todo.id)}
                        &gt;
                        {todo.text}
                        &lt;/span&gt;
                        &lt;button onClick={() =&gt; deleteTodo(todo.id)}&gt;Delete&lt;/button&gt;
                        &lt;/li&gt;
                        ))}
                        &lt;/ul&gt;
                        &lt;/div&gt;
                        );
                        };
                    </div>
                </div>

                <div id="nodejs" class="tab-content">
                    <h3>Node.js Server Code</h3>
                    <div class="code-block" data-language="JavaScript">
                        // Express.js with arrow functions
                        const express = require('express');
                        const app = express();

                        // Middleware
                        app.use(express.json());
                        app.use((req, res, next) => {
                        console.log(`${req.method} ${req.path} - ${new Date().toISOString()}`);
                        next();
                        });

                        // Route handlers
                        app.get('/api/users', async (req, res) => {
                        try {
                        const users = await User.find({});
                        res.json(users);
                        } catch (error) {
                        res.status(500).json({ error: error.message });
                        }
                        });

                        app.post('/api/users', async (req, res) => {
                        try {
                        const user = new User(req.body);
                        await user.save();
                        res.status(201).json(user);
                        } catch (error) {
                        res.status(400).json({ error: error.message });
                        }
                        });

                        // Error handling middleware
                        app.use((error, req, res, next) => {
                        console.error(error.stack);
                        res.status(500).json({ error: 'Something went wrong!' });
                        });

                        // Database operations
                        const UserService = {
                        create: async (userData) => {
                        const user = new User(userData);
                        return user.save();
                        },

                        findById: async (id) => {
                        return User.findById(id);
                        },

                        update: async (id, updates) => {
                        return User.findByIdAndUpdate(id, updates, { new: true });
                        },

                        delete: async (id) => {
                        return User.findByIdAndDelete(id);
                        }
                        };

                        // File operations
                        const fs = require('fs').promises;
                        const path = require('path');

                        const FileService = {
                        readFile: async (filename) => {
                        const filepath = path.join(__dirname, 'files', filename);
                        return fs.readFile(filepath, 'utf8');
                        },

                        writeFile: async (filename, content) => {
                        const filepath = path.join(__dirname, 'files', filename);
                        return fs.writeFile(filepath, content, 'utf8');
                        },

                        deleteFile: async (filename) => {
                        const filepath = path.join(__dirname, 'files', filename);
                        return fs.unlink(filepath);
                        }
                        };

                        // WebSocket server
                        const WebSocket = require('ws');
                        const wss = new WebSocket.Server({ port: 8080 });

                        wss.on('connection', (ws) => {
                        console.log('Client connected');

                        ws.on('message', (message) => {
                        const data = JSON.parse(message);

                        // Broadcast to all clients
                        wss.clients.forEach(client => {
                        if (client !== ws && client.readyState === WebSocket.OPEN) {
                        client.send(JSON.stringify(data));
                        }
                        });
                        });

                        ws.on('close', () => {
                        console.log('Client disconnected');
                        });
                        });
                    </div>
                </div>

                <div id="async" class="tab-content">
                    <h3>Async/Await Patterns</h3>
                    <div class="code-block" data-language="JavaScript">
                        // Async arrow functions
                        const fetchUserData = async (userId) => {
                        const response = await fetch(`/api/users/${userId}`);

                        if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }

                        return response.json();
                        };

                        // Parallel async operations
                        const fetchAllUserData = async (userId) => {
                        const [user, posts, comments] = await Promise.all([
                        fetchUserData(userId),
                        fetch(`/api/users/${userId}/posts`).then(r => r.json()),
                        fetch(`/api/users/${userId}/comments`).then(r => r.json())
                        ]);

                        return { user, posts, comments };
                        };

                        // Sequential async operations
                        const processUsersSequentially = async (userIds) => {
                        const results = [];

                        for (const userId of userIds) {
                        const userData = await fetchUserData(userId);
                        results.push(userData);
                        }

                        return results;
                        };

                        // Error handling with async/await
                        const safeAsyncOperation = async (operation) => {
                        try {
                        return await operation();
                        } catch (error) {
                        console.error('Async operation failed:', error);
                        throw error;
                        }
                        };

                        // Retry logic
                        const withRetry = (asyncFn, maxRetries = 3) => async (...args) => {
                        let lastError;

                        for (let i = 0; i < maxRetries; i++) { try { return await asyncFn(...args); } catch (error) {
                            lastError=error; if (i < maxRetries - 1) { await new Promise(resolve=> setTimeout(resolve,
                            1000 * (i + 1)));
                            }
                            }
                            }

                            throw lastError;
                            };

                            // Timeout wrapper
                            const withTimeout = (asyncFn, timeoutMs) => async (...args) => {
                            const timeoutPromise = new Promise((_, reject) => {
                            setTimeout(() => reject(new Error('Operation timed out')), timeoutMs);
                            });

                            return Promise.race([
                            asyncFn(...args),
                            timeoutPromise
                            ]);
                            };

                            // Usage examples
                            const robustFetch = withRetry(
                            withTimeout(fetchUserData, 5000),
                            3
                            );

                            const processUser = async (userId) => {
                            try {
                            const userData = await robustFetch(userId);
                            console.log('User data:', userData);
                            return userData;
                            } catch (error) {
                            console.error('Failed to process user:', error);
                            return null;
                            }
                            };

                            // Stream processing
                            const processStream = async (stream) => {
                            const results = [];

                            for await (const chunk of stream) {
                            const processed = await processChunk(chunk);
                            results.push(processed);
                            }

                            return results;
                            };

                            const processChunk = async (chunk) => {
                            // Simulate async processing
                            await new Promise(resolve => setTimeout(resolve, 100));
                            return chunk.toUpperCase();
                            };
                    </div>
                </div>

                <div id="functional" class="tab-content">
                    <h3>Functional Programming</h3>
                    <div class="code-block" data-language="JavaScript">
                        // Pure functions
                        const add = (a, b) => a + b;
                        const multiply = (a, b) => a * b;
                        const subtract = (a, b) => a - b;

                        // Function composition
                        const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);
                        const pipe = (...fns) => (value) => fns.reduce((acc, fn) => fn(acc), value);

                        // Math operations
                        const increment = x => x + 1;
                        const double = x => x * 2;
                        const square = x => x * x;

                        const transform = pipe(increment, double, square);
                        console.log(transform(3)); // ((3 + 1) * 2) ^ 2 = 64

                        // Currying
                        const curry = (fn) => (...args) => {
                        if (args.length >= fn.length) {
                        return fn(...args);
                        }
                        return (...nextArgs) => curry(fn)(...args, ...nextArgs);
                        };

                        const add3 = (a, b, c) => a + b + c;
                        const curriedAdd3 = curry(add3);

                        const add5 = curriedAdd3(2)(3);
                        console.log(add5(5)); // 10

                        // Partial application
                        const partial = (fn, ...args1) => (...args2) => fn(...args1, ...args2);

                        const log = (level, message) => console.log(`[${level}] ${message}`);
                        const logError = partial(log, 'ERROR');
                        const logInfo = partial(log, 'INFO');

                        // Higher-order functions
                        const map = (fn) => (array) => array.map(fn);
                        const filter = (predicate) => (array) => array.filter(predicate);
                        const reduce = (reducer, initial) => (array) => array.reduce(reducer, initial);

                        // Function combinators
                        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

                        const processNumbers = pipe(
                        filter(n => n % 2 === 0), // Even numbers
                        map(n => n * n), // Square them
                        reduce((sum, n) => sum + n, 0) // Sum them
                        );

                        console.log(processNumbers(numbers)); // 220

                        // Memoization
                        const memoize = (fn) => {
                        const cache = new Map();

                        return (...args) => {
                        const key = JSON.stringify(args);

                        if (cache.has(key)) {
                        return cache.get(key);
                        }

                        const result = fn(...args);
                        cache.set(key, result);
                        return result;
                        };
                        };

                        const fibonacci = memoize((n) => {
                        if (n <= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); }); // Functor pattern const
                            Maybe=(value)=> ({
                            map: (fn) => value != null ? Maybe(fn(value)) : Maybe(null),
                            getValue: () => value,
                            isNothing: () => value == null
                            });

                            const result = Maybe(5)
                            .map(x => x * 2)
                            .map(x => x + 1)
                            .getValue(); // 11

                            // Monadic operations
                            const chain = (fn) => (maybe) => maybe.isNothing() ? maybe : fn(maybe.getValue());

                            const safeOperation = (x) => {
                            if (x > 0) {
                            return Maybe(Math.sqrt(x));
                            }
                            return Maybe(null);
                            };

                            const chainedResult = Maybe(16)
                            .map(chain(safeOperation))
                            .getValue(); // 4
                    </div>
                </div>
            </div>
        </div>

        <div class="best-practices">
            <h3>üéØ Arrow Function Best Practices</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                <div>
                    <h4>When to Use Arrow Functions</h4>
                    <ul>
                        <li>Array methods (map, filter, reduce)</li>
                        <li>Event handlers in classes</li>
                        <li>Callbacks that need lexical 'this'</li>
                        <li>Short, simple functions</li>
                        <li>Function expressions</li>
                        <li>Higher-order functions</li>
                    </ul>
                </div>
                <div>
                    <h4>When to Avoid Arrow Functions</h4>
                    <ul>
                        <li>Object methods (unless you need lexical 'this')</li>
                        <li>Prototype methods</li>
                        <li>Functions that need to be hoisted</li>
                        <li>Constructor functions</li>
                        <li>Methods that need dynamic 'this'</li>
                        <li>Functions with complex logic</li>
                    </ul>
                </div>
                <div>
                    <h4>Performance Tips</h4>
                    <ul>
                        <li>Avoid creating arrow functions in render loops</li>
                        <li>Use regular methods for shared functionality</li>
                        <li>Consider memory usage with class properties</li>
                        <li>Profile performance-critical code</li>
                        <li>Use arrow functions for functional programming</li>
                        <li>Cache arrow functions when possible</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="highlight">
            <h3>üöÄ Advanced Arrow Function Techniques</h3>
            <p>
                <strong>Immediately Invoked Arrow Functions:</strong> Use ((param) => { ... })(arg) for immediate
                execution.<br>
                <strong>Conditional Arrow Functions:</strong> Use ternary operators for conditional logic in arrow
                functions.<br>
                <strong>Arrow Functions with Destructuring:</strong> Combine destructuring with arrow functions for
                cleaner code.<br>
                <strong>Tagged Template Literals:</strong> Use arrow functions with template literals for advanced
                string processing.
            </p>
        </div>
    </div>

    <script>
        // Tab functionality
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // Basic demo
        function runBasicDemo() {
            const output = document.getElementById('basic-output');
            output.style.display = 'block';

            let result = '';

            // Basic arrow functions
            const add = (a, b) => a + b;
            const square = x => x * x;
            const greet = name => `Hello, ${name}!`;

            result += `add(3, 5) = ${add(3, 5)}\n`;
            result += `square(4) = ${square(4)}\n`;
            result += `greet("Alice") = ${greet("Alice")}\n`;

            // Object creation
            const createUser = (name, age) => ({
                name,
                age,
                id: Math.random().toString(36).substr(2, 9)
            });

            const user = createUser("Bob", 30);
            result += `createUser: ${JSON.stringify(user)}\n`;

            // Array methods
            const numbers = [1, 2, 3, 4, 5];
            const doubled = numbers.map(n => n * 2);
            const evens = numbers.filter(n => n % 2 === 0);
            const sum = numbers.reduce((acc, n) => acc + n, 0);

            result += `doubled: [${doubled.join(', ')}]\n`;
            result += `evens: [${evens.join(', ')}]\n`;
            result += `sum: ${sum}\n`;

            // Rest parameters
            const multiply = (...args) => args.reduce((acc, n) => acc * n, 1);
            result += `multiply(2, 3, 4) = ${multiply(2, 3, 4)}\n`;

            output.textContent = result;
        }

        // This binding demo
        function runThisDemo() {
            const output = document.getElementById('this-output');
            output.style.display = 'block';

            let result = '';

            // Object with methods
            const obj = {
                name: 'TestObject',
                regularMethod: function () {
                    return `Regular method: ${this.name}`;
                },
                arrowMethod: () => {
                    return `Arrow method: ${this === window ? 'window' : 'other'}`;
                }
            };

            result += `${obj.regularMethod()}\n`;
            result += `${obj.arrowMethod()}\n`;

            // Simulating class behavior
            function Counter() {
                this.count = 0;
                this.name = 'Counter';

                this.increment = function () {
                    this.count++;
                    return this.count;
                };

                this.incrementArrow = () => {
                    this.count++;
                    return this.count;
                };
            }

            const counter = new Counter();
            result += `counter.increment(): ${counter.increment()}\n`;
            result += `counter.incrementArrow(): ${counter.incrementArrow()}\n`;

            // Method extraction
            const regularExtracted = counter.increment;
            const arrowExtracted = counter.incrementArrow;

            try {
                result += `extracted regular: ${regularExtracted()}\n`;
            } catch (e) {
                result += `extracted regular: Error - ${e.message}\n`;
            }

            result += `extracted arrow: ${arrowExtracted()}\n`;

            output.textContent = result;
        }

        // Advanced demo
        function runAdvancedDemo() {
            const output = document.getElementById('advanced-output');
            output.style.display = 'block';

            let result = '';

            // Higher-order functions
            const createMultiplier = (multiplier) => (value) => value * multiplier;
            const double = createMultiplier(2);
            const triple = createMultiplier(3);

            result += `double(5) = ${double(5)}\n`;
            result += `triple(4) = ${triple(4)}\n`;

            // Composition
            const compose = (...fns) => (value) => fns.reduceRight((acc, fn) => fn(acc), value);
            const addOne = x => x + 1;
            const square = x => x * x;
            const halve = x => x / 2;

            const transform = compose(halve, square, addOne);
            result += `transform(3) = ${transform(3)}\n`;

            // Currying
            const curry = (fn) => (...args) => {
                if (args.length >= fn.length) {
                    return fn(...args);
                }
                return (...nextArgs) => curry(fn)(...args, ...nextArgs);
            };

            const add3 = (a, b, c) => a + b + c;
            const curriedAdd3 = curry(add3);

            result += `curriedAdd3(1)(2)(3) = ${curriedAdd3(1)(2)(3)}\n`;

            // Array processing
            const data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            const processed = data
                .filter(n => n % 2 === 0)
                .map(n => n * n)
                .reduce((sum, n) => sum + n, 0);

            result += `processed data: ${processed}\n`;

            // Memoization
            const memoize = (fn) => {
                const cache = new Map();
                return (...args) => {
                    const key = JSON.stringify(args);
                    if (cache.has(key)) {
                        return cache.get(key);
                    }
                    const result = fn(...args);
                    cache.set(key, result);
                    return result;
                };
            };

            const fibonacci = memoize((n) => {
                if (n <= 1) return n;
                return fibonacci(n - 1) + fibonacci(n - 2);
            });

            result += `fibonacci(10) = ${fibonacci(10)}\n`;

            output.textContent = result;
        }

        // Performance demo
        function runPerformanceDemo() {
            const output = document.getElementById('performance-output');
            output.style.display = 'block';

            let result = '';

            const iterations = 100000;

            // Regular function
            function regular(x) {
                return x * 2;
            }

            // Arrow function
            const arrow = x => x * 2;

            // Performance test
            const start1 = performance.now();
            for (let i = 0; i < iterations; i++) {
                regular(i);
            }
            const end1 = performance.now();

            const start2 = performance.now();
            for (let i = 0; i < iterations; i++) {
                arrow(i);
            }
            const end2 = performance.now();

            result += `Performance Test (${iterations} iterations):\n`;
            result += `Regular function: ${(end1 - start1).toFixed(2)}ms\n`;
            result += `Arrow function: ${(end2 - start2).toFixed(2)}ms\n`;

            const ratio = (end2 - start2) / (end1 - start1);
            result += `Ratio: ${ratio.toFixed(2)}x\n`;

            // Memory usage test
            const memoryTest = () => {
                const objects = [];

                // Create objects with arrow functions
                for (let i = 0; i < 1000; i++) {
                    objects.push({
                        id: i,
                        process: () => i * 2
                    });
                }

                return objects.length;
            };

            const objectCount = memoryTest();
            result += `\nMemory test: Created ${objectCount} objects\n`;

            // Function creation performance
            const start3 = performance.now();
            for (let i = 0; i < iterations; i++) {
                const fn = x => x * 2;
            }
            const end3 = performance.now();

            result += `Function creation: ${(end3 - start3).toFixed(2)}ms\n`;

            output.textContent = result;
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function () {
            console.log('ES6 Arrow Functions guide loaded');

            // Animate performance bars
            const bars = document.querySelectorAll('.bar');
            bars.forEach(bar => {
                const height = bar.style.height;
                bar.style.height = '0px';
                setTimeout(() => {
                    bar.style.height = height;
                }, 500);
            });
        });
    </script>
</body>

</html>