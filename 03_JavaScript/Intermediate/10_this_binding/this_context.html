<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 'this' Binding & Context Patterns</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .hero {
            text-align: center;
            padding: 60px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .hero h1 {
            font-size: 3.5em;
            color: white;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .hero p {
            font-size: 1.3em;
            color: rgba(255, 255, 255, 0.9);
            max-width: 600px;
            margin: 0 auto;
        }

        .content-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .card h2 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            line-height: 1.5;
            overflow-x: auto;
            border-left: 4px solid #667eea;
        }

        .highlight {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #e17055;
        }

        .demo-container {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .demo-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #495057;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .output {
            background: #1a202c;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-family: monospace;
            min-height: 50px;
            border: 2px solid #2d3748;
            text-align: left;
        }

        .binding-rules {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .rule-card {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .rule-card h3 {
            margin-bottom: 15px;
        }

        .rule-card .priority {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            margin-top: 10px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            overflow-x: auto;
        }

        .tab {
            padding: 10px 20px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 1em;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: #667eea;
            color: white;
        }

        .tab-content {
            display: none;
            padding: 20px;
            background: white;
            border-radius: 0 8px 8px 8px;
        }

        .tab-content.active {
            display: block;
        }

        .concept-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .concept-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            transition: transform 0.3s ease;
        }

        .concept-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .concept-card h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .tip {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffecb5;
            color: #856404;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }

        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }

        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5em;
            }

            .binding-rules {
                grid-template-columns: 1fr;
            }

            .concept-grid {
                grid-template-columns: 1fr;
            }

            .tabs {
                flex-wrap: wrap;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="hero">
            <h1>üéØ 'this' Binding & Context</h1>
            <p>Master JavaScript's most confusing concept: understanding 'this' in all its forms</p>
        </div>

        <div class="content-grid">
            <div class="card">
                <h2>üß≠ What is 'this'?</h2>

                <p>The 'this' keyword in JavaScript refers to the context object. Its value depends on how a function is
                    called, not where it's defined.</p>

                <div class="binding-rules">
                    <div class="rule-card">
                        <h3>üìç Default Binding</h3>
                        <p>When no other rule applies</p>
                        <div class="priority">Lowest Priority</div>
                    </div>

                    <div class="rule-card">
                        <h3>üîó Implicit Binding</h3>
                        <p>When function is called as object method</p>
                        <div class="priority">Low Priority</div>
                    </div>

                    <div class="rule-card">
                        <h3>üìû Explicit Binding</h3>
                        <p>Using call(), apply(), bind()</p>
                        <div class="priority">High Priority</div>
                    </div>

                    <div class="rule-card">
                        <h3>üÜï new Binding</h3>
                        <p>When function is called with 'new'</p>
                        <div class="priority">Highest Priority</div>
                    </div>
                </div>

                <div class="code-block">
                    // The four binding rules in action

                    // 1. Default binding
                    function defaultExample() {
                    console.log(this); // Window (browser) or undefined (strict mode)
                    }

                    // 2. Implicit binding
                    const obj = {
                    name: "MyObject",
                    method: function() {
                    console.log(this.name); // "MyObject"
                    }
                    };

                    // 3. Explicit binding
                    function explicitExample() {
                    console.log(this.name);
                    }
                    explicitExample.call({name: "Explicit"}); // "Explicit"

                    // 4. new binding
                    function Constructor(name) {
                    this.name = name;
                    console.log(this); // New object instance
                    }
                    new Constructor("NewBinding");
                </div>

                <div class="demo-container">
                    <div class="demo-title">üéØ 'this' Binding Demo</div>
                    <button class="btn" onclick="runBindingDemo()">Test All Binding Rules</button>
                    <div id="binding-output" class="output"></div>
                </div>
            </div>

            <div class="card">
                <h2>üìç Default Binding</h2>

                <p>Default binding occurs when no other binding rule applies. It's the fallback binding.</p>

                <div class="tabs">
                    <button class="tab active" onclick="showTab('non-strict')">Non-Strict Mode</button>
                    <button class="tab" onclick="showTab('strict-mode')">Strict Mode</button>
                    <button class="tab" onclick="showTab('arrow-default')">Arrow Functions</button>
                </div>

                <div id="non-strict" class="tab-content active">
                    <h3>Non-Strict Mode</h3>
                    <div class="code-block">
                        // In non-strict mode, default binding points to global object
                        function defaultBinding() {
                        console.log(this); // Window object in browser
                        console.log(this === window); // true (in browser)
                        }

                        defaultBinding(); // Called without context

                        // Function expressions behave the same
                        const funcExpression = function() {
                        console.log(this === window); // true (in browser)
                        };

                        funcExpression();

                        // Immediately Invoked Function Expression (IIFE)
                        (function() {
                        console.log(this === window); // true
                        })();
                    </div>
                </div>

                <div id="strict-mode" class="tab-content">
                    <h3>Strict Mode</h3>
                    <div class="code-block">
                        'use strict';

                        // In strict mode, default binding is undefined
                        function strictDefault() {
                        console.log(this); // undefined
                        console.log(this === undefined); // true
                        }

                        strictDefault();

                        // This prevents accidental global variable creation
                        function accidentalGlobal() {
                        // this.newVar = "oops"; // TypeError in strict mode
                        // In non-strict mode, this would create window.newVar
                        }

                        // Module context (always strict)
                        // In ES6 modules, top-level 'this' is undefined
                        console.log(this); // undefined (in module context)
                    </div>
                </div>

                <div id="arrow-default" class="tab-content">
                    <h3>Arrow Functions</h3>
                    <div class="code-block">
                        // Arrow functions don't have their own 'this'
                        // They inherit 'this' from enclosing scope (lexical binding)

                        const arrowFunction = () => {
                        console.log(this); // Inherits from enclosing scope
                        };

                        // In global scope
                        arrowFunction(); // Window (non-strict) or undefined (strict/module)

                        // Inside object method
                        const obj = {
                        name: "Object",
                        regularMethod: function() {
                        console.log("Regular:", this.name); // "Object"

                        const arrowInside = () => {
                        console.log("Arrow inside:", this.name); // "Object" (inherited)
                        };

                        arrowInside();
                        }
                        };

                        obj.regularMethod();
                    </div>
                </div>

                <div class="demo-container">
                    <div class="demo-title">üìç Default Binding Demo</div>
                    <button class="btn" onclick="runDefaultBindingDemo()">Test Default Binding</button>
                    <div id="default-output" class="output"></div>
                </div>
            </div>

            <div class="card">
                <h2>üîó Implicit Binding</h2>

                <p>Implicit binding occurs when a function is called as a method of an object. The object becomes the
                    'this' context.</p>

                <div class="code-block">
                    // Basic implicit binding
                    const person = {
                    name: "Alice",
                    greet: function() {
                    console.log(`Hello, I'm ${this.name}`); // this = person
                    }
                    };

                    person.greet(); // "Hello, I'm Alice"

                    // Nested objects - only immediate parent matters
                    const company = {
                    name: "TechCorp",
                    department: {
                    name: "Engineering",
                    employee: {
                    name: "Bob",
                    introduce: function() {
                    console.log(`I'm ${this.name}`); // this = employee object
                    }
                    }
                    }
                    };

                    company.department.employee.introduce(); // "I'm Bob"

                    // Implicit binding can be lost!
                    const greetFunction = person.greet;
                    greetFunction(); // "Hello, I'm undefined" (lost context)
                </div>

                <div class="concept-grid">
                    <div class="concept-card">
                        <h3>‚úÖ Implicit Binding Works</h3>
                        <div class="code-block">
                            const obj = {
                            value: 42,
                            getValue: function() {
                            return this.value;
                            }
                            };

                            console.log(obj.getValue()); // 42
                            // Called as obj.method()
                        </div>
                    </div>

                    <div class="concept-card">
                        <h3>‚ùå Lost Implicit Binding</h3>
                        <div class="code-block">
                            const obj = {
                            value: 42,
                            getValue: function() {
                            return this.value;
                            }
                            };

                            const fn = obj.getValue;
                            console.log(fn()); // undefined
                            // Lost context when assigned
                        </div>
                    </div>

                    <div class="concept-card">
                        <h3>üéØ Common Pitfall</h3>
                        <div class="code-block">
                            const obj = {
                            name: "Object",
                            delayedGreet: function() {
                            setTimeout(function() {
                            console.log(this.name); // undefined
                            // Lost context in callback
                            }, 1000);
                            }
                            };

                            obj.delayedGreet();
                        </div>
                    </div>
                </div>

                <div class="demo-container">
                    <div class="demo-title">üîó Implicit Binding Demo</div>
                    <button class="btn" onclick="runImplicitBindingDemo()">Test Implicit Binding</button>
                    <div id="implicit-output" class="output"></div>
                </div>
            </div>

            <div class="card">
                <h2>üìû Explicit Binding</h2>

                <p>Explicit binding allows you to directly specify what 'this' should be using call(), apply(), or
                    bind().</p>

                <div class="tabs">
                    <button class="tab active" onclick="showTab('call-apply')">call() & apply()</button>
                    <button class="tab" onclick="showTab('bind-method')">bind()</button>
                    <button class="tab" onclick="showTab('hard-binding')">Hard Binding</button>
                </div>

                <div id="call-apply" class="tab-content active">
                    <h3>call() and apply()</h3>
                    <div class="code-block">
                        function greet(greeting, punctuation) {
                        console.log(`${greeting}, I'm ${this.name}${punctuation}`);
                        }

                        const person1 = { name: "Alice" };
                        const person2 = { name: "Bob" };

                        // call() - arguments passed individually
                        greet.call(person1, "Hello", "!"); // "Hello, I'm Alice!"
                        greet.call(person2, "Hi", "."); // "Hi, I'm Bob."

                        // apply() - arguments passed as array
                        greet.apply(person1, ["Hello", "!"]); // "Hello, I'm Alice!"
                        greet.apply(person2, ["Hi", "."]); // "Hi, I'm Bob."

                        // Practical example: Array methods on array-like objects
                        function borrowArrayMethods() {
                        // arguments is array-like but not an array
                        console.log(Array.prototype.slice.call(arguments));
                        console.log(Array.prototype.join.call(arguments, " | "));
                        }

                        borrowArrayMethods("a", "b", "c"); // ["a", "b", "c"], "a | b | c"

                        // Finding max in array using apply
                        const numbers = [5, 6, 2, 3, 7];
                        const max = Math.max.apply(null, numbers); // 7
                        console.log(max);
                    </div>
                </div>

                <div id="bind-method" class="tab-content">
                    <h3>bind() Method</h3>
                    <div class="code-block">
                        function introduce(greeting) {
                        console.log(`${greeting}, I'm ${this.name}`);
                        }

                        const person = { name: "Charlie" };

                        // bind() creates a new function with fixed 'this'
                        const boundIntroduce = introduce.bind(person);
                        boundIntroduce("Hello"); // "Hello, I'm Charlie"

                        // Even when called without context
                        const fn = boundIntroduce;
                        fn("Hi"); // "Hi, I'm Charlie" - still bound

                        // Partial application with bind
                        function fullIntroduction(greeting, role, company) {
                        console.log(`${greeting}, I'm ${this.name}, ${role} at ${company}`);
                        }

                        const employee = { name: "Diana" };
                        const boundWithArgs = fullIntroduction.bind(employee, "Hello");
                        boundWithArgs("Developer", "TechCorp"); // "Hello, I'm Diana, Developer at TechCorp"

                        // Event handlers - common use case
                        class Button {
                        constructor(element) {
                        this.element = element;
                        this.clickCount = 0;

                        // Bind to preserve 'this' context
                        this.element.addEventListener('click', this.handleClick.bind(this));
                        }

                        handleClick() {
                        this.clickCount++;
                        console.log(`Button clicked ${this.clickCount} times`);
                        }
                        }
                    </div>
                </div>

                <div id="hard-binding" class="tab-content">
                    <h3>Hard Binding Pattern</h3>
                    <div class="code-block">
                        // Hard binding - manually implementing bind-like behavior
                        function hardBind(fn, obj) {
                        return function() {
                        return fn.apply(obj, arguments);
                        };
                        }

                        function sayName() {
                        console.log(this.name);
                        }

                        const person = { name: "Eve" };
                        const hardBound = hardBind(sayName, person);

                        hardBound(); // "Eve"
                        hardBound.call({ name: "Other" }); // Still "Eve" - can't be overridden

                        // ES6 arrow function hard binding
                        const arrowBound = (...args) => sayName.apply(person, args);
                        arrowBound(); // "Eve"

                        // API wrapper example
                        function apiWrapper(baseUrl, timeout) {
                        function makeRequest(endpoint, options = {}) {
                        return fetch(`${this.baseUrl}${endpoint}`, {
                        ...options,
                        timeout: this.timeout
                        });
                        }

                        return makeRequest.bind({ baseUrl, timeout });
                        }

                        const api = apiWrapper('https://api.example.com', 5000);
                        // api() will always use the bound baseUrl and timeout
                    </div>
                </div>

                <div class="demo-container">
                    <div class="demo-title">üìû Explicit Binding Demo</div>
                    <button class="btn" onclick="runExplicitBindingDemo()">Test Explicit Binding</button>
                    <div id="explicit-output" class="output"></div>
                </div>
            </div>

            <div class="card">
                <h2>üÜï new Binding</h2>

                <p>When a function is called with 'new', a new object is created and becomes the 'this' context.</p>

                <div class="code-block">
                    // Constructor function
                    function Person(name, age) {
                    // 'this' refers to the newly created object
                    this.name = name;
                    this.age = age;
                    this.greet = function() {
                    console.log(`Hi, I'm ${this.name}`);
                    };

                    // Implicit return of 'this'
                    }

                    const alice = new Person("Alice", 30);
                    console.log(alice.name); // "Alice"
                    alice.greet(); // "Hi, I'm Alice"

                    // What happens with 'new':
                    // 1. New object created
                    // 2. New object's [[Prototype]] set to constructor's prototype
                    // 3. Constructor called with 'this' = new object
                    // 4. If constructor doesn't return object, return 'this'

                    // ES6 Class syntax (same behavior)
                    class Employee {
                    constructor(name, role) {
                    this.name = name;
                    this.role = role;
                    }

                    introduce() {
                    console.log(`I'm ${this.name}, a ${this.role}`);
                    }
                    }

                    const bob = new Employee("Bob", "Developer");
                    bob.introduce(); // "I'm Bob, a Developer"
                </div>

                <div class="concept-grid">
                    <div class="concept-card">
                        <h3>üèóÔ∏è Object Creation Steps</h3>
                        <ol>
                            <li>Create new empty object</li>
                            <li>Set prototype chain</li>
                            <li>Bind 'this' to new object</li>
                            <li>Execute constructor</li>
                            <li>Return new object</li>
                        </ol>
                    </div>

                    <div class="concept-card">
                        <h3>üéØ Manual Implementation</h3>
                        <div class="code-block">
                            function myNew(constructor, ...args) {
                            // Step 1: Create new object
                            const obj = {};

                            // Step 2: Set prototype
                            Object.setPrototypeOf(obj, constructor.prototype);

                            // Step 3 & 4: Call constructor with new object as 'this'
                            const result = constructor.apply(obj, args);

                            // Step 5: Return object or constructor result
                            return result instanceof Object ? result : obj;
                            }

                            // Usage
                            const person = myNew(Person, "Charlie", 25);
                        </div>
                    </div>

                    <div class="concept-card">
                        <h3>‚ö†Ô∏è Return Value Override</h3>
                        <div class="code-block">
                            function WeirdConstructor() {
                            this.value = 42;

                            // Explicit return of object overrides 'this'
                            return { different: "object" };
                            }

                            const weird = new WeirdConstructor();
                            console.log(weird.value); // undefined
                            console.log(weird.different); // "object"

                            // Primitive returns are ignored
                            function NormalConstructor() {
                            this.value = 42;
                            return "ignored"; // Primitive ignored
                            }

                            const normal = new NormalConstructor();
                            console.log(normal.value); // 42
                        </div>
                    </div>
                </div>

                <div class="demo-container">
                    <div class="demo-title">üÜï new Binding Demo</div>
                    <button class="btn" onclick="runNewBindingDemo()">Test new Binding</button>
                    <div id="new-output" class="output"></div>
                </div>
            </div>

            <div class="card">
                <h2>üèπ Arrow Functions & Lexical 'this'</h2>

                <p>Arrow functions don't have their own 'this'. They inherit 'this' from the enclosing scope (lexical
                    binding).</p>

                <div class="code-block">
                    // Arrow functions inherit 'this' from enclosing scope
                    const obj = {
                    name: "Object",

                    regularMethod: function() {
                    console.log("Regular method this:", this.name); // "Object"

                    // Arrow function inherits 'this' from regularMethod
                    const arrowFunction = () => {
                    console.log("Arrow function this:", this.name); // "Object"
                    };

                    arrowFunction();

                    // Even explicit binding can't change arrow function 'this'
                    arrowFunction.call({ name: "Other" }); // Still "Object"
                    },

                    // Arrow function as method - 'this' is from outer scope
                    arrowMethod: () => {
                    console.log("Arrow method this:", this.name); // undefined (global 'this')
                    }
                    };

                    obj.regularMethod();
                    obj.arrowMethod();
                </div>

                <div class="concept-grid">
                    <div class="concept-card">
                        <h3>‚úÖ Good Use Cases</h3>
                        <div class="code-block">
                            class Timer {
                            constructor() {
                            this.seconds = 0;

                            // Arrow function preserves 'this'
                            setInterval(() => {
                            this.seconds++;
                            console.log(this.seconds);
                            }, 1000);
                            }
                            }

                            // Event handlers
                            class Button {
                            constructor() {
                            this.clicks = 0;

                            document.addEventListener('click', () => {
                            this.clicks++; // 'this' refers to Button instance
                            });
                            }
                            }
                        </div>
                    </div>

                    <div class="concept-card">
                        <h3>‚ùå Avoid for Object Methods</h3>
                        <div class="code-block">
                            const calculator = {
                            value: 0,

                            // Bad: Arrow function doesn't get object as 'this'
                            add: (n) => {
                            this.value += n; // 'this' is not calculator
                            return this;
                            },

                            // Good: Regular method gets object as 'this'
                            subtract: function(n) {
                            this.value -= n;
                            return this;
                            }
                            };
                        </div>
                    </div>

                    <div class="concept-card">
                        <h3>üîÑ Callback Solutions</h3>
                        <div class="code-block">
                            class DataProcessor {
                            constructor() {
                            this.data = [];
                            }

                            // Problem: Lost 'this' in callback
                            processAsyncOld(callback) {
                            setTimeout(function() {
                            // this.data is undefined
                            callback(this.data);
                            }, 100);
                            }

                            // Solution 1: Arrow function
                            processAsyncArrow(callback) {
                            setTimeout(() => {
                            callback(this.data); // 'this' preserved
                            }, 100);
                            }

                            // Solution 2: bind()
                            processAsyncBind(callback) {
                            setTimeout(function() {
                            callback(this.data);
                            }.bind(this), 100);
                            }
                            }
                        </div>
                    </div>
                </div>

                <div class="demo-container">
                    <div class="demo-title">üèπ Arrow Function Demo</div>
                    <button class="btn" onclick="runArrowFunctionDemo()">Test Arrow Functions</button>
                    <div id="arrow-output" class="output"></div>
                </div>
            </div>

            <div class="card">
                <h2>üß© Common Patterns & Solutions</h2>

                <div class="tabs">
                    <button class="tab active" onclick="showTab('event-handlers')">Event Handlers</button>
                    <button class="tab" onclick="showTab('callbacks')">Callbacks</button>
                    <button class="tab" onclick="showTab('method-passing')">Method Passing</button>
                    <button class="tab" onclick="showTab('mixins')">Mixins</button>
                </div>

                <div id="event-handlers" class="tab-content active">
                    <h3>Event Handler Patterns</h3>
                    <div class="code-block">
                        class ClickCounter {
                        constructor(element) {
                        this.count = 0;
                        this.element = element;

                        // Problem: 'this' lost in event handler
                        // this.element.addEventListener('click', this.handleClick); // Wrong

                        // Solution 1: bind()
                        this.element.addEventListener('click', this.handleClick.bind(this));

                        // Solution 2: Arrow function wrapper
                        this.element.addEventListener('click', (event) => {
                        this.handleClick(event);
                        });

                        // Solution 3: Arrow function method (class field)
                        // this.handleClickArrow = (event) => { ... }
                        }

                        handleClick(event) {
                        this.count++;
                        console.log(`Clicked ${this.count} times`);
                        }

                        // Alternative: Arrow function property
                        handleClickArrow = (event) => {
                        this.count++;
                        console.log(`Arrow clicked ${this.count} times`);
                        }
                        }

                        // React-style event handling
                        class Component {
                        constructor() {
                        this.state = { count: 0 };
                        }

                        // Bind in constructor
                        constructor() {
                        this.handleClick = this.handleClick.bind(this);
                        }

                        // Or use arrow function property
                        handleClick = () => {
                        this.setState({ count: this.state.count + 1 });
                        }
                        }
                    </div>
                </div>

                <div id="callbacks" class="tab-content">
                    <h3>Callback Context Preservation</h3>
                    <div class="code-block">
                        class ApiClient {
                        constructor(baseUrl) {
                        this.baseUrl = baseUrl;
                        this.cache = new Map();
                        }

                        // Problem: 'this' lost in async callbacks
                        fetchDataProblem(endpoint, callback) {
                        fetch(`${this.baseUrl}${endpoint}`)
                        .then(function(response) {
                        return response.json();
                        })
                        .then(function(data) {
                        // 'this' is undefined here
                        this.cache.set(endpoint, data);
                        callback(data);
                        });
                        }

                        // Solution 1: Arrow functions
                        fetchDataArrow(endpoint, callback) {
                        fetch(`${this.baseUrl}${endpoint}`)
                        .then(response => response.json())
                        .then(data => {
                        this.cache.set(endpoint, data); // 'this' preserved
                        callback(data);
                        });
                        }

                        // Solution 2: Store reference
                        fetchDataRef(endpoint, callback) {
                        const self = this;
                        fetch(`${this.baseUrl}${endpoint}`)
                        .then(function(response) {
                        return response.json();
                        })
                        .then(function(data) {
                        self.cache.set(endpoint, data);
                        callback(data);
                        });
                        }

                        // Solution 3: bind()
                        fetchDataBind(endpoint, callback) {
                        fetch(`${this.baseUrl}${endpoint}`)
                        .then(function(response) {
                        return response.json();
                        })
                        .then(function(data) {
                        this.cache.set(endpoint, data);
                        callback(data);
                        }.bind(this));
                        }
                        }
                    </div>
                </div>

                <div id="method-passing" class="tab-content">
                    <h3>Method Passing Solutions</h3>
                    <div class="code-block">
                        class Logger {
                        constructor(prefix) {
                        this.prefix = prefix;
                        }

                        log(message) {
                        console.log(`[${this.prefix}] ${message}`);
                        }

                        // Create bound methods
                        getBoundLog() {
                        return this.log.bind(this);
                        }

                        // Arrow function property (auto-bound)
                        logArrow = (message) => {
                        console.log(`[${this.prefix}] ${message}`);
                        }
                        }

                        const logger = new Logger("INFO");

                        // Problem: Lost context
                        const logFunction = logger.log;
                        // logFunction("test"); // Error: this.prefix is undefined

                        // Solution 1: Bound method
                        const boundLog = logger.getBoundLog();
                        boundLog("test"); // Works!

                        // Solution 2: Arrow function method
                        const arrowLog = logger.logArrow;
                        arrowLog("test"); // Works!

                        // Solution 3: Wrapper function
                        function callWithLogger(fn, ...args) {
                        return fn.call(logger, ...args);
                        }
                        callWithLogger(logger.log, "test"); // Works!

                        // Higher-order function example
                        function createBoundMethods(obj) {
                        const bounded = {};

                        Object.getOwnPropertyNames(Object.getPrototypeOf(obj))
                        .filter(name => typeof obj[name] === 'function' && name !== 'constructor')
                        .forEach(name => {
                        bounded[name] = obj[name].bind(obj);
                        });

                        return bounded;
                        }
                    </div>
                </div>

                <div id="mixins" class="tab-content">
                    <h3>Mixins and 'this'</h3>
                    <div class="code-block">
                        // Mixin pattern with proper 'this' handling
                        const EventEmitterMixin = {
                        addEventListener(event, callback) {
                        if (!this._events) this._events = {};
                        if (!this._events[event]) this._events[event] = [];
                        this._events[event].push(callback);
                        },

                        removeEventListener(event, callback) {
                        if (!this._events || !this._events[event]) return;
                        this._events[event] = this._events[event].filter(cb => cb !== callback);
                        },

                        emit(event, ...args) {
                        if (!this._events || !this._events[event]) return;
                        this._events[event].forEach(callback => {
                        // Call with same 'this' context
                        callback.call(this, ...args);
                        });
                        }
                        };

                        class Component {
                        constructor(name) {
                        this.name = name;
                        }
                        }

                        // Mix in event emitter functionality
                        Object.assign(Component.prototype, EventEmitterMixin);

                        const component = new Component("MyComponent");

                        component.addEventListener('update', function(data) {
                        console.log(`${this.name} updated:`, data); // 'this' is component
                        });

                        component.emit('update', { version: '1.0' });

                        // Factory function approach
                        function createEventEmitter(target) {
                        return Object.assign(target, {
                        _events: {},

                        on(event, callback) {
                        if (!this._events[event]) this._events[event] = [];
                        this._events[event].push(callback);
                        return this; // Enable chaining
                        },

                        emit(event, ...args) {
                        if (this._events[event]) {
                        this._events[event].forEach(cb => cb.apply(this, args));
                        }
                        return this;
                        }
                        });
                        }
                    </div>
                </div>

                <div class="demo-container">
                    <div class="demo-title">üß© Patterns Demo</div>
                    <button class="btn" onclick="runPatternsDemo()">Test Common Patterns</button>
                    <div id="patterns-output" class="output"></div>
                </div>
            </div>

            <div class="card">
                <h2>üéØ Best Practices</h2>

                <div class="success">
                    <h3>‚úÖ Do:</h3>
                    <ul>
                        <li>Use arrow functions for callbacks that need to preserve 'this'</li>
                        <li>Use bind() for event handlers and method passing</li>
                        <li>Use regular functions for object methods</li>
                        <li>Use constructor functions or classes with 'new'</li>
                        <li>Be consistent with your 'this' binding strategy</li>
                        <li>Use explicit binding (call, apply, bind) when context is ambiguous</li>
                    </ul>
                </div>

                <div class="warning">
                    <h3>‚ùå Avoid:</h3>
                    <ul>
                        <li>Arrow functions as object methods (unless you need lexical 'this')</li>
                        <li>Forgetting to bind event handlers in classes</li>
                        <li>Mixing 'this' patterns inconsistently</li>
                        <li>Using 'this' in global functions (use explicit parameters instead)</li>
                        <li>Relying on default binding in strict mode</li>
                        <li>Complex nested binding that's hard to follow</li>
                    </ul>
                </div>

                <div class="tip">
                    <h3>üéØ Quick Reference:</h3>
                    <ul>
                        <li><strong>How was the function called?</strong> This determines 'this'</li>
                        <li><strong>new</strong> keyword ‚Üí new object</li>
                        <li><strong>call/apply/bind</strong> ‚Üí specified object</li>
                        <li><strong>obj.method()</strong> ‚Üí obj</li>
                        <li><strong>function()</strong> ‚Üí global object or undefined</li>
                        <li><strong>Arrow function</strong> ‚Üí lexical 'this'</li>
                    </ul>
                </div>

                <div class="demo-container">
                    <div class="demo-title">üéØ Complete 'this' Test</div>
                    <button class="btn" onclick="runCompleteThisTest()">Test All Concepts</button>
                    <div id="complete-this-output" class="output"></div>
                </div>
            </div>
        </div>

        <div class="highlight">
            <h3>üöÄ Key Takeaways</h3>
            <p>
                <strong>'this' is determined by how functions are called, not where they're defined.</strong><br>
                <strong>Binding Rules (priority order):</strong> new ‚Üí explicit ‚Üí implicit ‚Üí default<br>
                <strong>Arrow functions inherit 'this' lexically from enclosing scope.</strong><br>
                <strong>Use explicit binding (bind, call, apply) to control 'this' when needed.</strong><br>
                <strong>Common patterns: bind for events, arrows for callbacks, regular for methods.</strong>
            </p>
        </div>
    </div>

    <script>
        // Tab functionality
        function showTab(tabName) {
            // Get the parent card of the clicked tab
            const card = event.target.closest('.card');
            const tabContents = card.querySelectorAll('.tab-content');
            const tabs = card.querySelectorAll('.tab');

            // Hide all tab contents and remove active class from tabs
            tabContents.forEach(content => content.classList.remove('active'));
            tabs.forEach(tab => tab.classList.remove('active'));

            // Show selected tab content and activate tab
            card.querySelector(`#${tabName}`).classList.add('active');
            event.target.classList.add('active');
        }

        // Binding rules demonstration
        function runBindingDemo() {
            const output = document.getElementById('binding-output');
            let results = [];

            results.push('=== BINDING RULES DEMONSTRATION ===\n');

            // Default binding
            function defaultBinding() {
                return typeof this === 'undefined' ? 'undefined' : 'global object';
            }

            results.push('1. Default Binding:');
            results.push(`   defaultBinding() ‚Üí this is ${defaultBinding()}\n`);

            // Implicit binding
            const obj = {
                name: 'ImplicitObject',
                method: function () { return this.name; }
            };

            results.push('2. Implicit Binding:');
            results.push(`   obj.method() ‚Üí this.name is "${obj.method()}"`);

            const lostContext = obj.method;
            results.push(`   const fn = obj.method; fn() ‚Üí lost context: "${lostContext() || 'undefined'}"\n`);

            // Explicit binding
            function explicitBinding() {
                return this.name || 'no name';
            }

            const target = { name: 'ExplicitTarget' };
            results.push('3. Explicit Binding:');
            results.push(`   explicitBinding.call(target) ‚Üí "${explicitBinding.call(target)}"`);
            results.push(`   explicitBinding.apply(target) ‚Üí "${explicitBinding.apply(target)}"`);

            const bound = explicitBinding.bind(target);
            results.push(`   bound = explicitBinding.bind(target); bound() ‚Üí "${bound()}"\n`);

            // New binding
            function Constructor(name) {
                this.name = name;
                this.getName = function () { return this.name; };
            }

            const instance = new Constructor('NewBinding');
            results.push('4. New Binding:');
            results.push(`   new Constructor('NewBinding') ‚Üí instance.getName() = "${instance.getName()}"`);

            output.textContent = results.join('\n');
        }

        // Default binding demonstration
        function runDefaultBindingDemo() {
            const output = document.getElementById('default-output');
            let results = [];

            results.push('=== DEFAULT BINDING ===\n');

            function regularFunction() {
                return this === window ? 'window object' : (this === undefined ? 'undefined' : 'other');
            }

            const arrowFunction = () => {
                return this === window ? 'window object' : (this === undefined ? 'undefined' : 'other');
            };

            results.push('Regular function:');
            results.push(`this is: ${regularFunction()}\n`);

            results.push('Arrow function:');
            results.push(`this is: ${arrowFunction()}\n`);

            results.push('Note: In strict mode, regular function "this" would be undefined');
            results.push('Arrow functions inherit "this" from enclosing scope');

            output.textContent = results.join('\n');
        }

        // Implicit binding demonstration
        function runImplicitBindingDemo() {
            const output = document.getElementById('implicit-output');
            let results = [];

            results.push('=== IMPLICIT BINDING ===\n');

            const person = {
                name: 'Alice',
                greet: function () { return `Hello, I'm ${this.name}`; }
            };

            results.push('Object method call:');
            results.push(`person.greet() ‚Üí "${person.greet()}"\n`);

            // Lost binding
            const greetFunction = person.greet;
            results.push('Lost implicit binding:');
            results.push(`const fn = person.greet; fn() ‚Üí "${greetFunction() || 'undefined/error'}"\n`);

            // Nested objects
            const company = {
                name: 'TechCorp',
                department: {
                    name: 'Engineering',
                    getInfo: function () { return this.name; }
                }
            };

            results.push('Nested objects:');
            results.push(`company.department.getInfo() ‚Üí "${company.department.getInfo()}"`);
            results.push('(Only immediate parent matters for "this")');

            output.textContent = results.join('\n');
        }

        // Explicit binding demonstration
        function runExplicitBindingDemo() {
            const output = document.getElementById('explicit-output');
            let results = [];

            results.push('=== EXPLICIT BINDING ===\n');

            function greet(greeting, punctuation) {
                return `${greeting}, I'm ${this.name}${punctuation}`;
            }

            const person1 = { name: 'Alice' };
            const person2 = { name: 'Bob' };

            results.push('call() method:');
            results.push(`greet.call(person1, "Hello", "!") ‚Üí "${greet.call(person1, "Hello", "!")}"`);
            results.push(`greet.call(person2, "Hi", ".") ‚Üí "${greet.call(person2, "Hi", ".")}"\n`);

            results.push('apply() method:');
            results.push(`greet.apply(person1, ["Hello", "!"]) ‚Üí "${greet.apply(person1, ["Hello", "!"])}"\n`);

            results.push('bind() method:');
            const boundGreet = greet.bind(person1, "Hey");
            results.push(`const bound = greet.bind(person1, "Hey")`);
            results.push(`bound("?") ‚Üí "${boundGreet("?")}"`);

            output.textContent = results.join('\n');
        }

        // New binding demonstration
        function runNewBindingDemo() {
            const output = document.getElementById('new-output');
            let results = [];

            results.push('=== NEW BINDING ===\n');

            function Person(name, age) {
                this.name = name;
                this.age = age;
                this.introduce = function () {
                    return `I'm ${this.name}, ${this.age} years old`;
                };
            }

            results.push('Constructor function:');
            const alice = new Person('Alice', 30);
            results.push(`const alice = new Person('Alice', 30)`);
            results.push(`alice.introduce() ‚Üí "${alice.introduce()}"\n`);

            // Class syntax
            class Employee {
                constructor(name, role) {
                    this.name = name;
                    this.role = role;
                }

                getInfo() {
                    return `${this.name} - ${this.role}`;
                }
            }

            const bob = new Employee('Bob', 'Developer');
            results.push('ES6 Class:');
            results.push(`const bob = new Employee('Bob', 'Developer')`);
            results.push(`bob.getInfo() ‚Üí "${bob.getInfo()}"`);

            output.textContent = results.join('\n');
        }

        // Arrow function demonstration
        function runArrowFunctionDemo() {
            const output = document.getElementById('arrow-output');
            let results = [];

            results.push('=== ARROW FUNCTIONS & LEXICAL THIS ===\n');

            const obj = {
                name: 'TestObject',

                regularMethod: function () {
                    const arrowInside = () => {
                        return `Arrow inside regular: ${this.name}`;
                    };
                    return {
                        regular: `Regular method: ${this.name}`,
                        arrow: arrowInside()
                    };
                },

                arrowMethod: () => {
                    return `Arrow method: ${this.name || 'undefined (global this)'}`;
                }
            };

            const result = obj.regularMethod();
            results.push('Regular method with arrow inside:');
            results.push(result.regular);
            results.push(result.arrow);
            results.push('');

            results.push('Arrow function as object method:');
            results.push(obj.arrowMethod());
            results.push('(Arrow functions can\'t be bound to objects as methods)\n');

            // Callback example
            function simulateCallback(callback) {
                return callback();
            }

            const callbackObj = {
                value: 42,

                regularCallback: function () {
                    return simulateCallback(function () {
                        return `Regular callback this.value: ${this.value || 'undefined'}`;
                    });
                },

                arrowCallback: function () {
                    return simulateCallback(() => {
                        return `Arrow callback this.value: ${this.value}`;
                    });
                }
            };

            results.push('Callback context preservation:');
            results.push(callbackObj.regularCallback());
            results.push(callbackObj.arrowCallback());

            output.textContent = results.join('\n');
        }

        // Common patterns demonstration
        function runPatternsDemo() {
            const output = document.getElementById('patterns-output');
            let results = [];

            results.push('=== COMMON PATTERNS & SOLUTIONS ===\n');

            // Event handler pattern
            class ClickCounter {
                constructor() {
                    this.count = 0;
                }

                handleClick() {
                    this.count++;
                    return `Clicked ${this.count} times`;
                }

                getBoundHandler() {
                    return this.handleClick.bind(this);
                }

                getArrowHandler() {
                    return () => {
                        this.count++;
                        return `Arrow clicked ${this.count} times`;
                    };
                }
            }

            const counter = new ClickCounter();

            results.push('1. Event Handler Patterns:');
            const boundHandler = counter.getBoundHandler();
            results.push(`Bound handler: ${boundHandler()}`);

            const arrowHandler = counter.getArrowHandler();
            results.push(`Arrow handler: ${arrowHandler()}\n`);

            // Method passing
            class Logger {
                constructor(prefix) {
                    this.prefix = prefix;
                }

                log(message) {
                    return `[${this.prefix}] ${message}`;
                }
            }

            const logger = new Logger('INFO');

            results.push('2. Method Passing:');
            results.push('Direct call: ' + logger.log('test'));

            const boundLog = logger.log.bind(logger);
            results.push('Bound method: ' + boundLog('test'));

            // Callback preservation
            class ApiClient {
                constructor(baseUrl) {
                    this.baseUrl = baseUrl;
                }

                processResponse(data) {
                    return `Processed data from ${this.baseUrl}: ${data}`;
                }

                simulateAsync(data) {
                    // Simulate async callback with arrow function
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve(this.processResponse(data));
                        }, 0);
                    });
                }
            }

            const api = new ApiClient('https://api.example.com');
            results.push('\n3. Async Context Preservation:');
            results.push('Arrow function preserves context in async operations');

            output.textContent = results.join('\n');
        }

        // Complete 'this' test
        function runCompleteThisTest() {
            const output = document.getElementById('complete-this-output');
            let results = [];

            results.push('=== COMPLETE THIS BINDING TEST ===\n');

            // Test all scenarios
            function testFunction() {
                return this === window ? 'global' : this.name || 'undefined';
            }

            const testObj = {
                name: 'TestObject',
                method: testFunction
            };

            results.push('Test Function in Different Contexts:\n');

            results.push('1. Default binding:');
            results.push(`   testFunction() ‚Üí ${testFunction()}\n`);

            results.push('2. Implicit binding:');
            results.push(`   testObj.method() ‚Üí ${testObj.method()}\n`);

            results.push('3. Explicit binding:');
            const explicitTarget = { name: 'ExplicitTarget' };
            results.push(`   testFunction.call(explicitTarget) ‚Üí ${testFunction.call(explicitTarget)}`);
            results.push(`   testFunction.apply(explicitTarget) ‚Üí ${testFunction.apply(explicitTarget)}`);

            const bound = testFunction.bind(explicitTarget);
            results.push(`   bound = testFunction.bind(explicitTarget); bound() ‚Üí ${bound()}\n`);

            results.push('4. New binding:');
            function Constructor(name) {
                this.name = name;
                this.test = testFunction;
            }
            const instance = new Constructor('NewInstance');
            results.push(`   instance = new Constructor('NewInstance'); instance.test() ‚Üí ${instance.test()}\n`);

            results.push('5. Arrow function behavior:');
            const arrowTest = () => testFunction.call({ name: 'ArrowTarget' });
            results.push(`   Arrow function with explicit binding ‚Üí ${arrowTest()}`);
            results.push('   (Arrow functions ignore explicit binding for "this")\n');

            results.push('Priority Order: new > explicit > implicit > default');

            output.textContent = results.join('\n');
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function () {
            console.log('This binding guide loaded');
        });
    </script>
</body>

</html>